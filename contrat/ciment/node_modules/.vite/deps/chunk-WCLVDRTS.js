import {
  ifDefined
} from "./chunk-NCI2ONGC.js";
import {
  C,
  html,
  property,
  queryAssignedNodes
} from "./chunk-XM354YEY.js";

// node_modules/@spectrum-web-components/shared/src/random-id.dev.js
function randomID() {
  return Array.from(
    crypto.getRandomValues(new Uint8Array(4)),
    (b3) => `0${(b3 & 255).toString(16)}`.slice(-2)
  ).join("");
}

// node_modules/@spectrum-web-components/shared/src/focus-visible.dev.js
var hasFocusVisible = true;
try {
  document.body.querySelector(":focus-visible");
} catch (error) {
  hasFocusVisible = false;
  import("./focus-visible-VTMWFKK3.js");
}
var FocusVisiblePolyfillMixin = (SuperClass) => {
  var _a, _b;
  const coordinateWithPolyfill = (instance) => {
    if (instance.shadowRoot == null || instance.hasAttribute("data-js-focus-visible")) {
      return () => {
      };
    }
    if (self.applyFocusVisiblePolyfill) {
      self.applyFocusVisiblePolyfill(instance.shadowRoot);
      if (instance.manageAutoFocus) {
        instance.manageAutoFocus();
      }
    } else {
      const coordinationHandler = () => {
        if (self.applyFocusVisiblePolyfill && instance.shadowRoot) {
          self.applyFocusVisiblePolyfill(instance.shadowRoot);
        }
        if (instance.manageAutoFocus) {
          instance.manageAutoFocus();
        }
      };
      self.addEventListener(
        "focus-visible-polyfill-ready",
        coordinationHandler,
        { once: true }
      );
      return () => {
        self.removeEventListener(
          "focus-visible-polyfill-ready",
          coordinationHandler
        );
      };
    }
    return () => {
    };
  };
  const $endPolyfillCoordination = /* @__PURE__ */ Symbol("endPolyfillCoordination");
  class FocusVisibleCoordinator extends (_b = SuperClass, _a = $endPolyfillCoordination, _b) {
    constructor() {
      super(...arguments);
      this[_a] = null;
    }
    // Attempt to coordinate with the polyfill when connected to the
    // document:
    connectedCallback() {
      super.connectedCallback && super.connectedCallback();
      if (!hasFocusVisible) {
        requestAnimationFrame(() => {
          if (this[$endPolyfillCoordination] == null) {
            this[$endPolyfillCoordination] = coordinateWithPolyfill(this);
          }
        });
      }
    }
    disconnectedCallback() {
      super.disconnectedCallback && super.disconnectedCallback();
      if (!hasFocusVisible) {
        requestAnimationFrame(() => {
          if (this[$endPolyfillCoordination] != null) {
            this[$endPolyfillCoordination]();
            this[$endPolyfillCoordination] = null;
          }
        });
      }
    }
  }
  return FocusVisibleCoordinator;
};

// node_modules/@spectrum-web-components/base/src/condition-attribute-with-id.dev.js
function conditionAttributeWithoutId(el, attribute, ids) {
  const ariaDescribedby = el.getAttribute(attribute);
  let descriptors = ariaDescribedby ? ariaDescribedby.split(/\s+/) : [];
  descriptors = descriptors.filter(
    (descriptor) => !ids.find((id) => descriptor === id)
  );
  if (descriptors.length) {
    el.setAttribute(attribute, descriptors.join(" "));
  } else {
    el.removeAttribute(attribute);
  }
}
function conditionAttributeWithId(el, attribute, id) {
  const ids = Array.isArray(id) ? id : [id];
  const ariaDescribedby = el.getAttribute(attribute);
  const descriptors = ariaDescribedby ? ariaDescribedby.split(/\s+/) : [];
  const hadIds = ids.every((id2) => descriptors.indexOf(id2) > -1);
  if (hadIds)
    return () => {
      return;
    };
  descriptors.push(...ids);
  el.setAttribute(attribute, descriptors.join(" "));
  return () => conditionAttributeWithoutId(el, attribute, ids);
}

// node_modules/@spectrum-web-components/shared/src/reparent-children.dev.js
function restoreChildren(placeholderItems, srcElements, cleanupCallbacks = []) {
  for (let index = 0; index < srcElements.length; ++index) {
    const srcElement = srcElements[index];
    const placeholderItem = placeholderItems[index];
    const parentElement = placeholderItem.parentElement || placeholderItem.getRootNode();
    if (cleanupCallbacks[index]) {
      cleanupCallbacks[index](srcElement);
    }
    if (parentElement && parentElement !== placeholderItem) {
      parentElement.replaceChild(srcElement, placeholderItem);
    }
    delete placeholderItems[index];
  }
  return srcElements;
}
var reparentChildren = (srcElements, destination, {
  position,
  prepareCallback
} = { position: "beforeend" }) => {
  let { length } = srcElements;
  if (length === 0) {
    return () => srcElements;
  }
  let step = 1;
  let index = 0;
  if (position === "afterbegin" || position === "afterend") {
    step = -1;
    index = length - 1;
  }
  const placeholderItems = new Array(length);
  const cleanupCallbacks = new Array(length);
  const placeholderTemplate = document.createComment(
    "placeholder for reparented element"
  );
  do {
    const srcElement = srcElements[index];
    if (prepareCallback) {
      cleanupCallbacks[index] = prepareCallback(srcElement);
    }
    placeholderItems[index] = placeholderTemplate.cloneNode();
    const parentElement = srcElement.parentElement || srcElement.getRootNode();
    if (parentElement && parentElement !== srcElement) {
      parentElement.replaceChild(placeholderItems[index], srcElement);
    }
    destination.insertAdjacentElement(position, srcElement);
    index += step;
  } while (--length > 0);
  return function() {
    return restoreChildren(
      placeholderItems,
      srcElements,
      cleanupCallbacks
    );
  };
};

// node_modules/@spectrum-web-components/core/dist/node_modules/@lit-labs/observers/mutation-controller.js
var a = class {
  constructor(t, { target: s, config: e2, callback: i, skipInitial: h }) {
    this.t = /* @__PURE__ */ new Set(), this.o = false, this.i = false, this.h = t, s !== null && this.t.add(s ?? t), this.l = e2, this.o = h ?? this.o, this.callback = i, window.MutationObserver ? (this.u = new MutationObserver(((o) => {
      this.handleChanges(o), this.h.requestUpdate();
    })), t.addController(this)) : console.warn("MutationController error: browser does not support MutationObserver.");
  }
  handleChanges(t) {
    this.value = this.callback?.(t, this.u);
  }
  hostConnected() {
    for (const t of this.t) this.observe(t);
  }
  hostDisconnected() {
    this.disconnect();
  }
  async hostUpdated() {
    const t = this.u.takeRecords();
    (t.length || !this.o && this.i) && this.handleChanges(t), this.i = false;
  }
  observe(t) {
    this.t.add(t), this.u.observe(t, this.l), this.i = true, this.h.requestUpdate();
  }
  disconnect() {
    this.u.disconnect();
  }
};

// node_modules/@spectrum-web-components/core/dist/shared/observe-slot-presence.js
var e = /* @__PURE__ */ Symbol("slotContentIsPresent");
function b(a2, r) {
  var i, l;
  const n = Array.isArray(r) ? r : [r];
  class c extends (l = a2, i = e, l) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...t) {
      super(t), this[i] = /* @__PURE__ */ new Map(), this.managePresenceObservedSlot = () => {
        let o = false;
        n.forEach((s) => {
          const h = !!this.querySelector(`:scope > ${s}`), u = this[e].get(s) || false;
          o = o || u !== h, this[e].set(
            s,
            !!this.querySelector(`:scope > ${s}`)
          );
        }), o && this.updateComplete.then(() => {
          this.requestUpdate();
        });
      }, new a(this, {
        config: {
          childList: true,
          subtree: true
        },
        callback: () => {
          this.managePresenceObservedSlot();
        }
      }), this.managePresenceObservedSlot();
    }
    /**
     *  @private
     */
    get slotContentIsPresent() {
      if (n.length === 1)
        return this[e].get(n[0]) || false;
      throw new Error(
        "Multiple selectors provided to `ObserveSlotPresence` use `getSlotContentPresence(selector: string)` instead."
      );
    }
    getSlotContentPresence(t) {
      if (this[e].has(t))
        return this[e].get(t) || false;
      throw new Error(
        `The provided selector \`${t}\` is not being observed.`
      );
    }
  }
  return c;
}

// node_modules/@spectrum-web-components/shared/src/platform.dev.js
function testUserAgent(re) {
  return typeof window !== "undefined" && window.navigator != null ? re.test(window.navigator.userAgent) : false;
}
function testPlatform(re) {
  return typeof window !== "undefined" && window.navigator != null ? re.test(window.navigator.platform) : false;
}
function isMac() {
  return testPlatform(/^Mac/);
}
function isIPhone() {
  return testPlatform(/^iPhone/);
}
function isIPad() {
  return testPlatform(/^iPad/) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  isMac() && navigator.maxTouchPoints > 1;
}
function isIOS() {
  return isIPhone() || isIPad();
}
function isWebKit() {
  return testUserAgent(/AppleWebKit/) && !isChrome();
}
function isChrome() {
  return testUserAgent(/Chrome/);
}
function isAndroid() {
  return testUserAgent(/Android/);
}

// node_modules/@spectrum-web-components/shared/src/focusable.dev.js
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};
function nextFrame() {
  return new Promise((res) => requestAnimationFrame(() => res()));
}
var Focusable = class extends FocusVisiblePolyfillMixin(C) {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.autofocus = false;
    this._tabIndex = 0;
    this.manipulatingTabindex = false;
    this.autofocusReady = Promise.resolve();
  }
  get tabIndex() {
    if (this.focusElement === this) {
      const tabindex = this.hasAttribute("tabindex") ? Number(this.getAttribute("tabindex")) : NaN;
      return !isNaN(tabindex) ? tabindex : -1;
    }
    const tabIndexAttribute = parseFloat(
      this.hasAttribute("tabindex") ? this.getAttribute("tabindex") || "0" : "0"
    );
    if (this.disabled || tabIndexAttribute < 0) {
      return -1;
    }
    if (!this.focusElement) {
      return tabIndexAttribute;
    }
    return this._tabIndex;
  }
  set tabIndex(tabIndex) {
    var _a;
    if (this.manipulatingTabindex) {
      this.manipulatingTabindex = false;
      return;
    }
    if (this.focusElement === this) {
      if (this.disabled) {
        this._tabIndex = tabIndex;
      } else if (tabIndex !== this._tabIndex) {
        this._tabIndex = tabIndex;
        const tabindex = "" + tabIndex;
        this.manipulatingTabindex = true;
        this.setAttribute("tabindex", tabindex);
      }
      return;
    }
    if (tabIndex === -1) {
      this.addEventListener(
        "pointerdown",
        this.onPointerdownManagementOfTabIndex
      );
    } else {
      this.manipulatingTabindex = true;
      this.removeEventListener(
        "pointerdown",
        this.onPointerdownManagementOfTabIndex
      );
    }
    if (tabIndex === -1 || this.disabled) {
      this.manipulatingTabindex = true;
      this.setAttribute("tabindex", "-1");
      this.removeAttribute("focusable");
      if (this.selfManageFocusElement) {
        return;
      }
      if (tabIndex !== -1) {
        this._tabIndex = tabIndex;
        this.manageFocusElementTabindex(tabIndex);
      } else {
        (_a = this.focusElement) == null ? void 0 : _a.removeAttribute("tabindex");
      }
      return;
    }
    this.setAttribute("focusable", "");
    if (this.hasAttribute("tabindex")) {
      this.removeAttribute("tabindex");
    } else {
      this.manipulatingTabindex = false;
    }
    this._tabIndex = tabIndex;
    this.manageFocusElementTabindex(tabIndex);
  }
  onPointerdownManagementOfTabIndex() {
    if (this.tabIndex === -1) {
      setTimeout(() => {
        this.tabIndex = 0;
        this.focus({ preventScroll: true });
        this.tabIndex = -1;
      });
    }
  }
  async manageFocusElementTabindex(tabIndex) {
    if (!this.focusElement) {
      await this.updateComplete;
    }
    if (tabIndex === null) {
      this.focusElement.removeAttribute("tabindex");
    } else {
      if (this.focusElement !== this) {
        this.focusElement.tabIndex = tabIndex;
      }
    }
  }
  /**
   * @private
   */
  get focusElement() {
    throw new Error("Must implement focusElement getter!");
  }
  /**
   * @public
   * @returns {boolean} whether the component should manage its focusElement tab-index or not
   * Needed for action-menu to be supported in action-group in an accessible way
   */
  get selfManageFocusElement() {
    return false;
  }
  focus(options) {
    if (this.disabled || !this.focusElement) {
      return;
    }
    if (this.focusElement !== this) {
      this.focusElement.focus(options);
    } else {
      HTMLElement.prototype.focus.apply(this, [options]);
    }
  }
  blur() {
    const focusElement = this.focusElement || this;
    if (focusElement !== this) {
      focusElement.blur();
    } else {
      HTMLElement.prototype.blur.apply(this);
    }
  }
  click() {
    if (this.disabled) {
      return;
    }
    const focusElement = this.focusElement || this;
    if (focusElement !== this) {
      focusElement.click();
    } else {
      HTMLElement.prototype.click.apply(this);
    }
  }
  manageAutoFocus() {
    if (this.autofocus) {
      this.dispatchEvent(
        new KeyboardEvent("keydown", {
          code: "Tab"
        })
      );
      this.focusElement.focus();
    }
  }
  firstUpdated(changes) {
    super.firstUpdated(changes);
    if (!this.hasAttribute("tabindex") || this.getAttribute("tabindex") !== "-1") {
      this.setAttribute("focusable", "");
    }
  }
  update(changedProperties) {
    if (changedProperties.has("disabled")) {
      this.handleDisabledChanged(
        this.disabled,
        changedProperties.get("disabled")
      );
    }
    super.update(changedProperties);
  }
  updated(changedProperties) {
    super.updated(changedProperties);
    if (changedProperties.has("disabled") && this.disabled) {
      this.blur();
    }
  }
  async handleDisabledChanged(disabled, oldDisabled) {
    const canSetDisabled = () => this.focusElement !== this && typeof this.focusElement.disabled !== "undefined";
    if (disabled) {
      this.manipulatingTabindex = true;
      this.setAttribute("tabindex", "-1");
      await this.updateComplete;
      if (canSetDisabled()) {
        this.focusElement.disabled = true;
      } else {
        this.setAttribute("aria-disabled", "true");
      }
    } else if (oldDisabled) {
      this.manipulatingTabindex = true;
      if (this.focusElement === this) {
        this.setAttribute("tabindex", "" + this._tabIndex);
      } else {
        this.removeAttribute("tabindex");
      }
      await this.updateComplete;
      if (canSetDisabled()) {
        this.focusElement.disabled = false;
      } else {
        this.removeAttribute("aria-disabled");
      }
    }
  }
  async getUpdateComplete() {
    const complete = await super.getUpdateComplete();
    await this.autofocusReady;
    return complete;
  }
  connectedCallback() {
    super.connectedCallback();
    if (this.autofocus) {
      this.autofocusReady = new Promise(async (res) => {
        await nextFrame();
        await nextFrame();
        res();
      });
      this.updateComplete.then(() => {
        this.manageAutoFocus();
      });
    }
  }
};
__decorateClass([
  property({ type: Boolean, reflect: true })
], Focusable.prototype, "disabled", 2);
__decorateClass([
  property({ type: Boolean })
], Focusable.prototype, "autofocus", 2);
__decorateClass([
  property({ type: Number })
], Focusable.prototype, "tabIndex", 1);

// node_modules/@spectrum-web-components/shared/src/like-anchor.dev.js
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __decorateClass2 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc2(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp2(target, key, result);
  return result;
};
function LikeAnchor(constructor) {
  class LikeAnchorElement extends constructor {
    renderAnchor({
      id,
      className,
      ariaHidden,
      labelledby,
      tabindex,
      // prettier-ignore
      anchorContent = html`<slot></slot>`
    }) {
      return html`<a
                    id=${id}
                    class=${ifDefined(className)}
                    href=${ifDefined(this.href)}
                    download=${ifDefined(this.download)}
                    target=${ifDefined(this.target)}
                    aria-label=${ifDefined(this.label)}
                    aria-labelledby=${ifDefined(labelledby)}
                    aria-hidden=${ifDefined(ariaHidden ? "true" : void 0)}
                    tabindex=${ifDefined(tabindex)}
                    referrerpolicy=${ifDefined(this.referrerpolicy)}
                    rel=${ifDefined(this.rel)}
                >${anchorContent}</a>`;
    }
  }
  __decorateClass2([
    property()
  ], LikeAnchorElement.prototype, "download", 2);
  __decorateClass2([
    property()
  ], LikeAnchorElement.prototype, "label", 2);
  __decorateClass2([
    property()
  ], LikeAnchorElement.prototype, "href", 2);
  __decorateClass2([
    property()
  ], LikeAnchorElement.prototype, "target", 2);
  __decorateClass2([
    property()
  ], LikeAnchorElement.prototype, "referrerpolicy", 2);
  __decorateClass2([
    property()
  ], LikeAnchorElement.prototype, "rel", 2);
  return LikeAnchorElement;
}

// node_modules/@spectrum-web-components/core/dist/shared/observe-slot-text.js
var b2 = Object.defineProperty;
var p = (d, n, i, u) => {
  for (var t = void 0, r = d.length - 1, o; r >= 0; r--)
    (o = d[r]) && (t = o(n, i, t) || t);
  return t && b2(n, i, t), t;
};
var f = /* @__PURE__ */ Symbol("assignedNodes");
function N(d, n, i = []) {
  var u, t;
  const r = (c) => (e2) => c.matches(e2);
  class o extends (t = d, u = f, t) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...e2) {
      super(e2), this.slotHasContent = false, new a(this, {
        config: {
          characterData: true,
          subtree: true
        },
        callback: (l) => {
          for (const s of l)
            if (s.type === "characterData") {
              this.manageTextObservedSlot();
              return;
            }
        }
      });
    }
    manageTextObservedSlot() {
      if (!this[f])
        return;
      const e2 = [...this[f]].filter(
        (l) => {
          const s = l;
          return s.tagName ? !i.some(r(s)) : s.textContent ? s.textContent.trim() : false;
        }
      );
      this.slotHasContent = e2.length > 0;
    }
    update(e2) {
      if (!this.hasUpdated) {
        const { childNodes: l } = this, s = [...l].filter((h) => {
          const a2 = h;
          return a2.tagName ? i.some(
            r(a2)
          ) ? false : (
            // This pass happens at element upgrade and before slot rendering.
            // Confirm it would exisit in a targeted slot if there was one supplied.
            n ? a2.getAttribute("slot") === n : !a2.hasAttribute("slot")
          ) : a2.textContent ? a2.textContent.trim() : false;
        });
        this.slotHasContent = s.length > 0;
      }
      super.update(e2);
    }
    firstUpdated(e2) {
      super.firstUpdated(e2), this.updateComplete.then(() => {
        this.manageTextObservedSlot();
      });
    }
  }
  return p([
    property({ type: Boolean, attribute: false })
  ], o.prototype, "slotHasContent"), p([
    queryAssignedNodes({
      slot: n,
      flatten: true
    })
  ], o.prototype, u), o;
}

export {
  FocusVisiblePolyfillMixin,
  Focusable,
  LikeAnchor,
  N,
  randomID,
  conditionAttributeWithoutId,
  conditionAttributeWithId,
  reparentChildren,
  b,
  isIPhone,
  isIOS,
  isWebKit,
  isAndroid
};
//# sourceMappingURL=chunk-WCLVDRTS.js.map
