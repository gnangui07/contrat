import {
  conditionAttributeWithId,
  isAndroid,
  isIOS,
  isWebKit,
  randomID,
  reparentChildren
} from "./chunk-WCLVDRTS.js";
import {
  ifDefined,
  styleMap
} from "./chunk-NCI2ONGC.js";
import {
  firstFocusableIn,
  firstFocusableSlottedIn,
  userFocusableSelector
} from "./chunk-L7KH37RZ.js";
import {
  C,
  css,
  html,
  property,
  query,
  queryAssignedElements,
  state
} from "./chunk-XM354YEY.js";

// node_modules/@spectrum-web-components/reactive-controllers/src/ElementResolution.dev.js
var elementResolverUpdatedSymbol = /* @__PURE__ */ Symbol("element resolver updated");
var ElementResolutionController = class {
  constructor(host, { selector } = { selector: "" }) {
    this._element = null;
    this._selector = "";
    this.mutationCallback = (mutationList) => {
      let needsResolution = false;
      mutationList.forEach((mutation) => {
        if (needsResolution) return;
        if (mutation.type === "childList") {
          const currentElementRemoved = this.element && [...mutation.removedNodes].includes(this.element);
          const matchingElementAdded = !!this.selector && [...mutation.addedNodes].some(
            this.elementIsSelected
          );
          needsResolution = needsResolution || currentElementRemoved || matchingElementAdded;
        }
        if (mutation.type === "attributes") {
          const attributeChangedOnCurrentElement = mutation.target === this.element;
          const attributeChangedOnMatchingElement = !!this.selector && this.elementIsSelected(mutation.target);
          needsResolution = needsResolution || attributeChangedOnCurrentElement || attributeChangedOnMatchingElement;
        }
      });
      if (needsResolution) {
        this.resolveElement();
      }
    };
    this.elementIsSelected = (el) => {
      var _a;
      return this.selectorIsId ? (el == null ? void 0 : el.id) === this.selectorAsId : (_a = el == null ? void 0 : el.matches) == null ? void 0 : _a.call(el, this.selector);
    };
    this.host = host;
    this.selector = selector;
    this.observer = new MutationObserver(this.mutationCallback);
    this.host.addController(this);
  }
  get element() {
    return this._element;
  }
  set element(element) {
    if (element === this.element) return;
    const previous = this.element;
    this._element = element;
    this.host.requestUpdate(elementResolverUpdatedSymbol, previous);
  }
  get selector() {
    return this._selector;
  }
  set selector(selector) {
    if (selector === this.selector) return;
    this.releaseElement();
    this._selector = selector;
    this.resolveElement();
  }
  get selectorAsId() {
    return this.selector.slice(1);
  }
  get selectorIsId() {
    return !!this.selector && this.selector.startsWith("#");
  }
  hostConnected() {
    this.resolveElement();
    this.observer.observe(this.host.getRootNode(), {
      subtree: true,
      childList: true,
      attributes: true
    });
  }
  hostDisconnected() {
    this.releaseElement();
    this.observer.disconnect();
  }
  resolveElement() {
    if (!this.selector) {
      this.releaseElement();
      return;
    }
    const parent = this.host.getRootNode();
    this.element = this.selectorIsId ? parent.getElementById(this.selectorAsId) : parent.querySelector(this.selector);
  }
  releaseElement() {
    this.element = null;
  }
};

// node_modules/@spectrum-web-components/overlay/src/overlay-timer.dev.js
var DEFAULT_WARMUP = 1e3;
var DEFAULT_COOLDOWN = 1e3;
var OverlayTimer = class {
  constructor(options = {}) {
    this.warmUpDelay = DEFAULT_WARMUP;
    this.coolDownDelay = DEFAULT_COOLDOWN;
    this.isWarm = false;
    this.timeout = 0;
    Object.assign(this, options);
  }
  async openTimer(component) {
    this.cancelCooldownTimer();
    if (!this.component || component !== this.component) {
      if (this.component) {
        this.close(this.component);
        this.cancelCooldownTimer();
      }
      this.component = component;
      if (this.isWarm) {
        return false;
      }
      this.promise = new Promise((resolve) => {
        this.resolve = resolve;
        this.timeout = window.setTimeout(() => {
          if (this.resolve) {
            this.resolve(false);
            this.isWarm = true;
          }
        }, this.warmUpDelay);
      });
      return this.promise;
    } else if (this.promise) {
      return this.promise;
    } else {
      throw new Error("Inconsistent state");
    }
  }
  close(component) {
    if (this.component && this.component === component) {
      this.resetCooldownTimer();
      if (this.timeout > 0) {
        clearTimeout(this.timeout);
        this.timeout = 0;
      }
      if (this.resolve) {
        this.resolve(true);
        delete this.resolve;
      }
      delete this.promise;
      delete this.component;
    }
  }
  resetCooldownTimer() {
    if (this.isWarm) {
      if (this.cooldownTimeout) {
        window.clearTimeout(this.cooldownTimeout);
      }
      this.cooldownTimeout = window.setTimeout(() => {
        this.isWarm = false;
        delete this.cooldownTimeout;
      }, this.coolDownDelay);
    }
  }
  cancelCooldownTimer() {
    if (this.cooldownTimeout) {
      window.clearTimeout(this.cooldownTimeout);
    }
    delete this.cooldownTimeout;
  }
};

// node_modules/@spectrum-web-components/overlay/src/AbstractOverlay.dev.js
var overlayTimer = new OverlayTimer();
var noop = () => {
  return;
};
var guaranteedAllTransitionend = (el, action, cb) => {
  const abortController = new AbortController();
  const runningTransitions = /* @__PURE__ */ new Map();
  const cleanup = () => {
    abortController.abort();
    cb();
  };
  let guarantee2;
  let guarantee3;
  const guarantee1 = requestAnimationFrame(() => {
    guarantee2 = requestAnimationFrame(() => {
      guarantee3 = requestAnimationFrame(() => {
        cleanup();
      });
    });
  });
  const handleTransitionend = (event) => {
    if (event.target !== el) {
      return;
    }
    runningTransitions.set(
      event.propertyName,
      runningTransitions.get(event.propertyName) - 1
    );
    if (!runningTransitions.get(event.propertyName)) {
      runningTransitions.delete(event.propertyName);
    }
    if (runningTransitions.size === 0) {
      cleanup();
    }
  };
  const handleTransitionrun = (event) => {
    if (event.target !== el) {
      return;
    }
    if (!runningTransitions.has(event.propertyName)) {
      runningTransitions.set(event.propertyName, 0);
    }
    runningTransitions.set(
      event.propertyName,
      runningTransitions.get(event.propertyName) + 1
    );
    cancelAnimationFrame(guarantee1);
    cancelAnimationFrame(guarantee2);
    cancelAnimationFrame(guarantee3);
  };
  el.addEventListener("transitionrun", handleTransitionrun, {
    signal: abortController.signal
  });
  el.addEventListener("transitionend", handleTransitionend, {
    signal: abortController.signal
  });
  el.addEventListener("transitioncancel", handleTransitionend, {
    signal: abortController.signal
  });
  action();
};
function nextFrame() {
  return new Promise((res) => requestAnimationFrame(() => res()));
}
var AbstractOverlay = class _AbstractOverlay extends C {
  constructor() {
    super(...arguments);
    this.dispose = noop;
    this.offset = 0;
    this.willPreventClose = false;
  }
  async applyFocus(_targetOpenState, _focusEl) {
    return;
  }
  /* c8 ignore next 6 */
  get delayed() {
    return false;
  }
  set delayed(_delayed) {
    return;
  }
  /* c8 ignore next 6 */
  get disabled() {
    return false;
  }
  set disabled(_disabled) {
    return;
  }
  get elementResolver() {
    return this._elementResolver;
  }
  set elementResolver(controller) {
    this._elementResolver = controller;
  }
  /* c8 ignore next 3 */
  async ensureOnDOM(_targetOpenState) {
    return;
  }
  /* c8 ignore next 5 */
  async makeTransition(_targetOpenState) {
    return null;
  }
  async manageDelay(_targetOpenState) {
    return;
  }
  /* c8 ignore next 3 */
  async managePopoverOpen() {
    return;
  }
  /* c8 ignore next 3 */
  managePosition() {
    return;
  }
  /* c8 ignore next 6 */
  get open() {
    return false;
  }
  set open(_open) {
    return;
  }
  get placementController() {
    return this._placementController;
  }
  set placementController(controller) {
    this._placementController = controller;
  }
  requestSlottable() {
  }
  returnFocus() {
    return;
  }
  /* c8 ignore next 6 */
  get state() {
    return "closed";
  }
  set state(_state) {
    return;
  }
  /* c8 ignore next 3 */
  manuallyKeepOpen() {
    return;
  }
  static update() {
    const overlayUpdateEvent = new CustomEvent("sp-update-overlays", {
      bubbles: true,
      composed: true,
      cancelable: true
    });
    document.dispatchEvent(overlayUpdateEvent);
  }
  static async open(triggerOrContent, interactionOrOptions, content, optionsV1) {
    await import("./sp-overlay.dev-J2AT5RMJ.js");
    const v2 = arguments.length === 2;
    const overlayContent = content || triggerOrContent;
    const overlay = new this();
    let restored = false;
    overlay.dispose = () => {
      overlay.addEventListener("sp-closed", () => {
        if (!restored) {
          restoreContent();
          restored = true;
        }
        requestAnimationFrame(() => {
          overlay.remove();
        });
      });
      overlay.open = false;
      overlay.dispose = noop;
    };
    const restoreContent = reparentChildren([overlayContent], overlay, {
      position: "beforeend",
      prepareCallback: (el) => {
        const slot = el.slot;
        el.removeAttribute("slot");
        return () => {
          el.slot = slot;
        };
      }
    });
    const v1 = !v2 && overlayContent && optionsV1;
    if (v1) {
      if (true) {
        window.__swc.warn(
          overlay,
          `You are interacting with an ${overlay.localName} element via a deprecated imperative API. This API will be removed in a future version of the SWC library. Consider leveraging an ${overlay.localName} directly.`,
          "https://opensource.adobe.com/spectrum-web-components/components/overlay/",
          { level: "deprecation" }
        );
      }
      const trigger = triggerOrContent;
      const interaction = interactionOrOptions;
      const options2 = optionsV1;
      _AbstractOverlay.applyOptions(overlay, {
        ...options2,
        delayed: options2.delayed || overlayContent.hasAttribute("delayed"),
        trigger: options2.virtualTrigger || trigger,
        type: interaction === "modal" ? "modal" : interaction === "hover" ? "hint" : "auto"
      });
      trigger.insertAdjacentElement("afterend", overlay);
      await overlay.updateComplete;
      overlay.open = true;
      return overlay.dispose;
    }
    const options = interactionOrOptions;
    overlay.append(overlayContent);
    _AbstractOverlay.applyOptions(overlay, {
      ...options,
      delayed: options.delayed || overlayContent.hasAttribute("delayed")
    });
    overlay.updateComplete.then(() => {
      overlay.open = true;
    });
    return overlay;
  }
  static applyOptions(overlay, options) {
    var _a, _b;
    overlay.delayed = !!options.delayed;
    overlay.receivesFocus = (_a = options.receivesFocus) != null ? _a : "auto";
    overlay.triggerElement = options.trigger || null;
    overlay.type = options.type || "modal";
    overlay.offset = (_b = options.offset) != null ? _b : 0;
    overlay.placement = options.placement;
    overlay.willPreventClose = !!options.notImmediatelyClosable;
  }
  disconnectedCallback() {
    super.disconnectedCallback();
  }
};

// node_modules/@spectrum-web-components/overlay/src/VirtualTrigger.dev.js
var VirtualTrigger = class {
  constructor(x, y) {
    this.x = 0;
    this.y = 0;
    this.x = x;
    this.y = y;
  }
  updateBoundingClientRect(x, y) {
    this.x = x;
    this.y = y;
    AbstractOverlay.update();
  }
  getBoundingClientRect() {
    return {
      width: 0,
      height: 0,
      top: this.y,
      right: this.x,
      y: this.y,
      x: this.x,
      bottom: this.y,
      left: this.x,
      /* c8 ignore next 3 */
      toJSON() {
        return;
      }
    };
  }
};

// node_modules/@spectrum-web-components/overlay/src/events.dev.js
var BeforetoggleClosedEvent = class extends Event {
  constructor() {
    super("beforetoggle", {
      bubbles: false,
      composed: false
    });
    this.currentState = "open";
    this.newState = "closed";
  }
};
var BeforetoggleOpenEvent = class extends Event {
  constructor() {
    super("beforetoggle", {
      bubbles: false,
      composed: false
    });
    this.currentState = "closed";
    this.newState = "open";
  }
};
var OverlayStateEvent = class extends Event {
  constructor(type, overlay, {
    publish,
    interaction,
    reason
  }) {
    super(type, {
      bubbles: publish,
      composed: publish
    });
    this.overlay = overlay;
    this.detail = {
      interaction,
      reason
    };
  }
};

// node_modules/@spectrum-web-components/overlay/src/OverlayPopover.dev.js
var supportsOverlayAuto = CSS.supports("(overlay: auto)");
function isOpen(el) {
  let popoverOpen = false;
  try {
    popoverOpen = el.matches(":popover-open");
  } catch (error) {
  }
  let open = false;
  try {
    open = el.matches(":open");
  } catch (error) {
  }
  return popoverOpen || open;
}
function OverlayPopover(constructor) {
  class OverlayWithPopover extends constructor {
    async manageDelay(targetOpenState) {
      if (targetOpenState === false || targetOpenState !== this.open) {
        overlayTimer.close(this);
        return;
      }
      if (this.delayed) {
        const cancelled = await overlayTimer.openTimer(this);
        if (cancelled) {
          this.open = !targetOpenState;
        }
      }
    }
    /**
     * A popover should be hidden _after_ it is no longer on top-layer because
     * the position metrics will have changed from when it was originally positioned.
     */
    async shouldHidePopover(targetOpenState) {
      if (targetOpenState && this.open !== targetOpenState) {
        return;
      }
      const update = async ({
        newState
      } = {}) => {
        if (newState === "open") {
          return;
        }
        await this.placementController.resetOverlayPosition();
      };
      if (!isOpen(this.dialogEl)) {
        update();
        return;
      }
      this.dialogEl.addEventListener("toggle", update, {
        once: true
      });
    }
    shouldShowPopover(targetOpenState) {
      let popoverOpen = false;
      try {
        popoverOpen = this.dialogEl.matches(":popover-open");
      } catch (error) {
      }
      let open = false;
      try {
        open = this.dialogEl.matches(":open");
      } catch (error) {
      }
      if (targetOpenState && this.open === targetOpenState && !popoverOpen && !open && this.isConnected) {
        this.dialogEl.showPopover();
        this.managePosition();
      }
    }
    async ensureOnDOM(targetOpenState) {
      if (!supportsOverlayAuto) {
        await this.shouldHidePopover(targetOpenState);
      }
      this.shouldShowPopover(targetOpenState);
      await nextFrame();
    }
    async makeTransition(targetOpenState) {
      if (this.open !== targetOpenState) {
        return null;
      }
      let focusEl = null;
      const start = (el, index) => () => {
        el.open = targetOpenState;
        if (index === 0) {
          const event = targetOpenState ? BeforetoggleOpenEvent : BeforetoggleClosedEvent;
          this.dispatchEvent(new event());
        }
        if (!targetOpenState) {
          return;
        }
        if (el.matches(userFocusableSelector)) {
          focusEl = el;
        }
        focusEl = focusEl || firstFocusableIn(el);
        if (focusEl) {
          return;
        }
        const childSlots = el.querySelectorAll("slot");
        childSlots.forEach((slot) => {
          if (!focusEl) {
            focusEl = firstFocusableSlottedIn(slot);
          }
        });
      };
      const finish = (el, index) => async () => {
        if (this.open !== targetOpenState) {
          return;
        }
        const eventName = targetOpenState ? "sp-opened" : "sp-closed";
        if (index > 0) {
          el.dispatchEvent(
            new OverlayStateEvent(eventName, this, {
              interaction: this.type,
              publish: false
            })
          );
          return;
        }
        const reportChange = async () => {
          if (this.open !== targetOpenState) {
            return;
          }
          await nextFrame();
          const hasVirtualTrigger = this.triggerElement instanceof VirtualTrigger;
          this.dispatchEvent(
            new OverlayStateEvent(eventName, this, {
              interaction: this.type,
              publish: hasVirtualTrigger
            })
          );
          el.dispatchEvent(
            new OverlayStateEvent(eventName, this, {
              interaction: this.type,
              publish: false
            })
          );
          if (this.triggerElement && !hasVirtualTrigger) {
            this.triggerElement.dispatchEvent(
              new OverlayStateEvent(eventName, this, {
                interaction: this.type,
                publish: true
              })
            );
          }
          this.state = targetOpenState ? "opened" : "closed";
          this.returnFocus();
          await nextFrame();
          await nextFrame();
          if (targetOpenState === this.open && targetOpenState === false) {
            this.requestSlottable();
          }
        };
        if (this.open !== targetOpenState) {
          return;
        }
        const open = isOpen(this.dialogEl);
        if (targetOpenState !== true && open && this.isConnected) {
          this.dialogEl.addEventListener(
            "beforetoggle",
            () => {
              reportChange();
            },
            { once: true }
          );
          this.dialogEl.hidePopover();
        } else {
          reportChange();
        }
      };
      this.elements.forEach((el, index) => {
        guaranteedAllTransitionend(
          el,
          start(el, index),
          finish(el, index)
        );
      });
      return focusEl;
    }
  }
  return OverlayWithPopover;
}

// node_modules/@spectrum-web-components/overlay/src/OverlayNoPopover.dev.js
function OverlayNoPopover(constructor) {
  class OverlayWithNoPopover extends constructor {
    async managePopoverOpen() {
      await this.managePosition();
    }
    async manageDelay(targetOpenState) {
      if (targetOpenState === false || targetOpenState !== this.open) {
        overlayTimer.close(this);
        return;
      }
      if (this.delayed) {
        const cancelled = await overlayTimer.openTimer(this);
        if (cancelled) {
          this.open = !targetOpenState;
        }
      }
    }
    async ensureOnDOM(_targetOpenState) {
      document.body.offsetHeight;
    }
    async makeTransition(targetOpenState) {
      if (this.open !== targetOpenState) {
        return null;
      }
      let focusEl = null;
      const start = (el, index) => () => {
        if (targetOpenState !== this.open) {
          return;
        }
        el.open = targetOpenState;
        if (index === 0) {
          const event = targetOpenState ? BeforetoggleOpenEvent : BeforetoggleClosedEvent;
          this.dispatchEvent(new event());
        }
        if (targetOpenState !== true) {
          return;
        }
        if (el.matches(userFocusableSelector)) {
          focusEl = el;
        }
        focusEl = focusEl || firstFocusableIn(el);
        if (focusEl) {
          return;
        }
        const childSlots = el.querySelectorAll("slot");
        childSlots.forEach((slot) => {
          if (!focusEl) {
            focusEl = firstFocusableSlottedIn(slot);
          }
        });
      };
      const finish = (el, index) => async () => {
        if (this.open !== targetOpenState) {
          return;
        }
        const eventName = targetOpenState ? "sp-opened" : "sp-closed";
        el.dispatchEvent(
          new OverlayStateEvent(eventName, this, {
            interaction: this.type
          })
        );
        if (index > 0) {
          return;
        }
        const hasVirtualTrigger = this.triggerElement instanceof VirtualTrigger;
        this.dispatchEvent(
          new OverlayStateEvent(eventName, this, {
            interaction: this.type,
            publish: hasVirtualTrigger
          })
        );
        if (this.triggerElement && !hasVirtualTrigger) {
          this.triggerElement.dispatchEvent(
            new OverlayStateEvent(eventName, this, {
              interaction: this.type,
              publish: true
            })
          );
        }
        this.state = targetOpenState ? "opened" : "closed";
        this.returnFocus();
        await nextFrame();
        await nextFrame();
        if (targetOpenState === this.open && targetOpenState === false) {
          this.requestSlottable();
        }
      };
      this.elements.forEach((el, index) => {
        guaranteedAllTransitionend(
          el,
          start(el, index),
          finish(el, index)
        );
      });
      return focusEl;
    }
  }
  return OverlayWithNoPopover;
}

// node_modules/@spectrum-web-components/overlay/src/OverlayStack.dev.js
var supportsPopover = "showPopover" in document.createElement("div");
var OverlayStack = class {
  constructor() {
    this.root = document.body;
    this.stack = [];
    this.originalBodyOverflow = "";
    this.bodyScrollBlocked = false;
    this.handleScroll = (event) => {
      if (event.target !== document && event.target !== document.documentElement && event.target !== document.body) {
        return;
      }
      this.stack.forEach((overlay) => {
        if (overlay.open) {
          if (overlay.type === "auto" && overlay.triggerElement instanceof HTMLElement && overlay.triggerElement.closest("sp-picker, sp-action-menu")) {
            event.stopPropagation();
          }
          document.dispatchEvent(
            new CustomEvent("sp-update-overlays", {
              bubbles: true,
              composed: true,
              cancelable: true
            })
          );
        }
      });
    };
    this.handlePointerdown = (event) => {
      this.pointerdownPath = event.composedPath();
      this.lastOverlay = this.stack[this.stack.length - 1];
    };
    this.handlePointerup = () => {
      const composedPath = this.pointerdownPath;
      this.pointerdownPath = void 0;
      if (!this.stack.length) return;
      if (!(composedPath == null ? void 0 : composedPath.length)) return;
      const lastOverlay = this.lastOverlay;
      this.lastOverlay = void 0;
      const lastIndex = this.stack.length - 1;
      const nonAncestorOverlays = this.stack.filter((overlay, i) => {
        const inStack = composedPath.find(
          (el) => (
            // The Overlay is in the stack
            el === overlay || // The Overlay trigger is in the stack and the Overlay is a "hint"
            el === (overlay == null ? void 0 : overlay.triggerElement) && "hint" === (overlay == null ? void 0 : overlay.type) || // The last Overlay in the stack is not the last Overlay at `pointerdown` time and has a
            // `triggerInteraction` of "longpress", meaning it was opened by this poitner interaction
            i === lastIndex && overlay !== lastOverlay && overlay.triggerInteraction === "longpress"
          )
        );
        return !inStack && !overlay.shouldPreventClose() && overlay.type !== "manual" && // Don't close if this overlay is modal and not on top of the overlay stack.
        !(overlay.type === "modal" && lastOverlay !== overlay);
      });
      nonAncestorOverlays.reverse();
      nonAncestorOverlays.forEach((overlay) => {
        this.closeOverlay(overlay);
        let parentToClose = overlay.parentOverlayToForceClose;
        while (parentToClose) {
          this.closeOverlay(parentToClose);
          parentToClose = parentToClose.parentOverlayToForceClose;
        }
      });
    };
    this.handleBeforetoggle = (event) => {
      const { target, newState: open } = event;
      if (open === "open") return;
      this.closeOverlay(target);
    };
    this.handleKeydown = (event) => {
      if (event.code !== "Escape") return;
      if (!this.stack.length) return;
      const last = this.stack[this.stack.length - 1];
      if ((last == null ? void 0 : last.type) === "page") {
        event.preventDefault();
        return;
      }
      if ((last == null ? void 0 : last.type) === "manual") {
        this.closeOverlay(last);
        return;
      }
      if (supportsPopover) return;
      if (!last) return;
      this.closeOverlay(last);
    };
    this.bindEvents();
  }
  get document() {
    return this.root.ownerDocument || document;
  }
  bindEvents() {
    this.document.addEventListener("pointerdown", this.handlePointerdown);
    this.document.addEventListener("pointerup", this.handlePointerup);
    this.document.addEventListener("keydown", this.handleKeydown);
    this.document.addEventListener("scroll", this.handleScroll, {
      capture: true
    });
  }
  closeOverlay(overlay) {
    const overlayIndex = this.stack.indexOf(overlay);
    if (overlayIndex > -1) {
      this.stack.splice(overlayIndex, 1);
    }
    overlay.open = false;
    this.manageBodyScroll();
  }
  /**
   * Manage body scroll blocking based on modal/page overlays
   */
  manageBodyScroll() {
    const shouldBlock = this.stack.some(
      (overlay) => overlay.type === "modal" || overlay.type === "page"
    );
    if (shouldBlock && !this.bodyScrollBlocked) {
      this.originalBodyOverflow = document.body.style.overflow || "";
      document.body.style.overflow = "hidden";
      this.bodyScrollBlocked = true;
    } else if (!shouldBlock && this.bodyScrollBlocked) {
      document.body.style.overflow = this.originalBodyOverflow;
      this.bodyScrollBlocked = false;
    }
  }
  /**
   * Get an array of Overlays that all share the same trigger element.
   *
   * @param triggerElement {HTMLELement}
   * @returns {Overlay[]}
   */
  overlaysByTriggerElement(triggerElement) {
    return this.stack.filter(
      (overlay) => overlay.triggerElement === triggerElement
    );
  }
  /**
   * When overlays are added manage the open state of exisiting overlays appropriately:
   * - 'modal': should close other non-'modal' and non-'manual' overlays
   * - 'page': should close other non-'modal' and non-'manual' overlays
   * - 'auto': should close other 'auto' overlays and other 'hint' overlays, but not 'manual' overlays
   * - 'manual': shouldn't close other overlays
   * - 'hint': shouldn't close other overlays and give way to all other overlays on a trigger
   */
  add(overlay) {
    if (this.stack.includes(overlay)) {
      const overlayIndex = this.stack.indexOf(overlay);
      if (overlayIndex > -1) {
        this.stack.splice(overlayIndex, 1);
        this.stack.push(overlay);
      }
      return;
    }
    if (overlay.type === "auto" || overlay.type === "modal" || overlay.type === "page") {
      const queryPathEventName = "sp-overlay-query-path";
      const queryPathEvent = new Event(queryPathEventName, {
        composed: true,
        bubbles: true
      });
      overlay.addEventListener(
        queryPathEventName,
        (event) => {
          const path = event.composedPath();
          this.stack.forEach((overlayEl) => {
            const inPath = path.find((el) => el === overlayEl);
            if (!inPath && overlayEl.type !== "manual" && overlayEl.type !== "modal") {
              this.closeOverlay(overlayEl);
            }
          });
        },
        { once: true }
      );
      overlay.dispatchEvent(queryPathEvent);
    } else if (overlay.type === "hint") {
      const hasPrevious = this.stack.some((overlayEl) => {
        return overlayEl.type !== "manual" && overlayEl.triggerElement && overlayEl.triggerElement === overlay.triggerElement;
      });
      if (hasPrevious) {
        overlay.open = false;
        return;
      }
      this.stack.forEach((overlayEl) => {
        if (overlayEl.type === "hint") {
          this.closeOverlay(overlayEl);
        }
      });
    }
    requestAnimationFrame(() => {
      this.stack.push(overlay);
      overlay.addEventListener("beforetoggle", this.handleBeforetoggle, {
        once: true
      });
      this.manageBodyScroll();
    });
  }
  remove(overlay) {
    this.closeOverlay(overlay);
  }
};
var overlayStack = new OverlayStack();

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
var yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(placement) {
  return yAxisSides.has(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
var lrPlacement = ["left", "right"];
var rlPlacement = ["right", "left"];
var tbPlacement = ["top", "bottom"];
var btPlacement = ["bottom", "top"];
function getSideList(side, isStart, rtl) {
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rlPlacement : lrPlacement;
      return isStart ? lrPlacement : rlPlacement;
    case "left":
    case "right":
      return isStart ? tbPlacement : btPlacement;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state2, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state2;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state2);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state2) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state2;
    const {
      element,
      padding = 0
    } = evaluate(options, state2) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset3 = clamp(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset3 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset3,
        centerOffset: center - offset3 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state2) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state2;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state2);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state2, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
          // overflows the main axis.
          overflowsData.every((d) => getSideAxis(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
var originSides = /* @__PURE__ */ new Set(["left", "top"]);
async function convertValueToCoords(state2, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state2;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = originSides.has(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state2);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state2) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state2;
      const diffCoords = await convertValueToCoords(state2, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state2) {
      const {
        x,
        y,
        placement
      } = state2;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state2);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state2, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state2,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state2) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state2;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state2);
      const overflow = await detectOverflow(state2, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state2.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state2.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state2.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state2,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
var invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
}
var tableElements = /* @__PURE__ */ new Set(["table", "td", "th"]);
function isTableElement(element) {
  return tableElements.has(getNodeName(element));
}
var topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
  return topLayerSelectors.some((selector) => {
    try {
      return element.matches(selector);
    } catch (_e) {
      return false;
    }
  });
}
var transformProperties = ["transform", "translate", "scale", "rotate", "perspective"];
var willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
var containValues = ["paint", "layout", "strict", "content"];
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit2();
  const css2 = isElement(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;
  return transformProperties.some((value) => css2[value] ? css2[value] !== "none" : false) || (css2.containerType ? css2.containerType !== "normal" : false) || !webkit && (css2.backdropFilter ? css2.backdropFilter !== "none" : false) || !webkit && (css2.filter ? css2.filter !== "none" : false) || willChangeValues.some((value) => (css2.willChange || "").includes(value)) || containValues.some((value) => (css2.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit2() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
var lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function isLastTraversableNode(node) {
  return lastTraversableNodeNames.has(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css2 = getComputedStyle2(element);
  let width = parseFloat(css2.width) || 0;
  let height = parseFloat(css2.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit2() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css2 = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css2.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css2.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll) {
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html2 = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html2.scrollWidth, html2.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html2.scrollHeight, html2.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x += max(html2.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
var SCROLLBAR_MAX = 25;
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html2 = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html2.clientWidth;
  let height = html2.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit2();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  const windowScrollbarX = getWindowScrollBarX(html2);
  if (windowScrollbarX <= 0) {
    const doc = html2.ownerDocument;
    const body = doc.body;
    const bodyStyles = getComputedStyle(body);
    const bodyMarginInline = doc.compatMode === "CSS1Compat" ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;
    const clippingStableScrollbarWidth = Math.abs(html2.clientWidth - body.clientWidth - bodyMarginInline);
    if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {
      width -= clippingStableScrollbarWidth;
    }
  } else if (windowScrollbarX <= SCROLLBAR_MAX) {
    width += windowScrollbarX;
  }
  return {
    width,
    height,
    x,
    y
  };
}
var absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a, b) {
  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (_e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var arrow2 = arrow;
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/@spectrum-web-components/overlay/src/PlacementController.dev.js
function roundByDPR(num) {
  if (typeof num === "undefined") return 0;
  const dpr = window.devicePixelRatio || 1;
  return Math.round(num * dpr) / dpr;
}
var REQUIRED_DISTANCE_TO_EDGE = 8;
var MIN_OVERLAY_HEIGHT = 100;
var getFallbackPlacements = (placement) => {
  var _a;
  const fallbacks = {
    left: ["right", "bottom", "top"],
    "left-start": ["right-start", "bottom", "top"],
    "left-end": ["right-end", "bottom", "top"],
    right: ["left", "bottom", "top"],
    "right-start": ["left-start", "bottom", "top"],
    "right-end": ["left-end", "bottom", "top"],
    top: ["bottom", "left", "right"],
    "top-start": ["bottom-start", "left", "right"],
    "top-end": ["bottom-end", "left", "right"],
    bottom: ["top", "left", "right"],
    "bottom-start": ["top-start", "left", "right"],
    "bottom-end": ["top-end", "left", "right"]
  };
  return (_a = fallbacks[placement]) != null ? _a : [placement];
};
var PlacementController = class {
  /**
   * Creates an instance of the PlacementController.
   *
   * @param {ReactiveElement & { elements: OpenableElement[] }} host - The host element that uses this controller.
   */
  constructor(host) {
    this.originalPlacements = /* @__PURE__ */ new WeakMap();
    this.allowPlacementUpdate = false;
    this.closeForAncestorUpdate = () => {
      if (!this.allowPlacementUpdate && this.options.type !== "modal" && this.cleanup) {
        this.target.dispatchEvent(new Event("close", { bubbles: true }));
      }
      this.allowPlacementUpdate = false;
    };
    this.updatePlacement = () => {
      this.computePlacement();
    };
    this.resetOverlayPosition = () => {
      if (!this.target || !this.options) return;
      this.clearOverlayPosition();
      this.host.offsetHeight;
      this.computePlacement();
    };
    this.host = host;
    this.host.addController(this);
  }
  /**
   * Places the overlay relative to the target element.
   *
   * This method sets up the necessary configurations and event listeners to manage the
   * positioning and constraints of the overlay element.
   *
   * @param {HTMLElement} [target=this.target] - The target element for the overlay.
   * @param {OverlayOptionsV1} [options=this.options] - The options for configuring the overlay placement.
   * @returns {Promise<void>} A promise that resolves when the overlay has been placed.
   */
  async placeOverlay(target = this.target, options = this.options) {
    this.target = target;
    this.options = options;
    if (!target || !options) return;
    const cleanupAncestorResize = autoUpdate(
      options.trigger,
      target,
      this.closeForAncestorUpdate,
      {
        ancestorResize: false,
        elementResize: false,
        layoutShift: false
      }
    );
    const cleanupElementResize = autoUpdate(
      options.trigger,
      target,
      this.updatePlacement,
      {
        ancestorScroll: false
      }
    );
    this.cleanup = () => {
      var _a;
      (_a = this.host.elements) == null ? void 0 : _a.forEach((element) => {
        element.addEventListener(
          "sp-closed",
          () => {
            const placement = this.originalPlacements.get(element);
            if (placement) {
              element.setAttribute("placement", placement);
            }
            this.originalPlacements.delete(element);
          },
          { once: true }
        );
      });
      cleanupAncestorResize();
      cleanupElementResize();
    };
  }
  /**
   * Computes the placement of the overlay relative to the target element.
   *
   * This method calculates the necessary positioning and constraints for the overlay element
   * using various middleware functions. It updates the overlay's style and attributes based
   * on the computed position.
   *
   * @returns {Promise<void>} A promise that resolves when the placement has been computed.
   */
  async computePlacement() {
    var _a, _b;
    const { options, target } = this;
    await (document.fonts ? document.fonts.ready : Promise.resolve());
    const flipMiddleware = !(options.trigger instanceof HTMLElement) ? flip2({
      padding: REQUIRED_DISTANCE_TO_EDGE,
      fallbackPlacements: getFallbackPlacements(options.placement)
    }) : flip2();
    const [mainAxis = 0, crossAxis = 0] = Array.isArray(options == null ? void 0 : options.offset) ? options.offset : [options.offset, 0];
    const tipElement = (_a = this.host.elements.find(
      (el) => el.tipElement
    )) == null ? void 0 : _a.tipElement;
    const middleware = [
      offset2({
        mainAxis,
        crossAxis
      }),
      shift2({ padding: REQUIRED_DISTANCE_TO_EDGE }),
      flipMiddleware,
      size2({
        padding: REQUIRED_DISTANCE_TO_EDGE,
        apply: ({
          availableWidth,
          availableHeight,
          rects: { floating }
        }) => {
          const maxHeight = Math.max(
            MIN_OVERLAY_HEIGHT,
            Math.floor(availableHeight)
          );
          const actualHeight = floating.height;
          this.initialHeight = !this.isConstrained ? actualHeight : this.initialHeight || actualHeight;
          this.isConstrained = actualHeight < this.initialHeight || maxHeight <= actualHeight;
          const appliedHeight = this.isConstrained ? `${maxHeight}px` : "";
          Object.assign(target.style, {
            maxWidth: `${Math.floor(availableWidth)}px`,
            maxHeight: appliedHeight
          });
        }
      }),
      ...tipElement ? [
        arrow2({
          element: tipElement,
          padding: options.tipPadding || REQUIRED_DISTANCE_TO_EDGE
        })
      ] : []
    ];
    const { x, y, placement, middlewareData } = await computePosition2(
      options.trigger,
      target,
      {
        placement: options.placement,
        middleware,
        strategy: "fixed"
      }
    );
    Object.assign(target.style, {
      top: "0px",
      left: "0px",
      translate: `${roundByDPR(x)}px ${roundByDPR(y)}px`
    });
    target.setAttribute("actual-placement", placement);
    (_b = this.host.elements) == null ? void 0 : _b.forEach((element) => {
      if (!this.originalPlacements.has(element)) {
        this.originalPlacements.set(
          element,
          element.getAttribute("placement")
        );
      }
      element.setAttribute("placement", placement);
    });
    if (tipElement && middlewareData.arrow) {
      const { x: arrowX, y: arrowY } = middlewareData.arrow;
      Object.assign(tipElement.style, {
        top: placement.startsWith("right") || placement.startsWith("left") ? "0px" : "",
        left: placement.startsWith("bottom") || placement.startsWith("top") ? "0px" : "",
        translate: `${roundByDPR(arrowX)}px ${roundByDPR(arrowY)}px`
      });
    }
  }
  /**
   * Clears the overlay's position styles.
   *
   * This method removes the max-height and max-width styles from the target element,
   * and resets the initial height and constrained state of the overlay.
   */
  clearOverlayPosition() {
    if (!this.target) {
      return;
    }
    this.target.style.removeProperty("max-height");
    this.target.style.removeProperty("max-width");
    this.initialHeight = void 0;
    this.isConstrained = false;
  }
  /**
   * Lifecycle method called when the host element is connected to the DOM.
   *
   * This method sets up an event listener to reset the overlay's position when the 'sp-update-overlays' event is dispatched.
   */
  hostConnected() {
    document.addEventListener(
      "sp-update-overlays",
      this.resetOverlayPosition
    );
  }
  /**
   * Lifecycle method called when the host element is updated.
   *
   * This method cleans up resources if the overlay is not open.
   */
  hostUpdated() {
    var _a;
    if (!this.host.open) {
      (_a = this.cleanup) == null ? void 0 : _a.call(this);
      this.cleanup = void 0;
    }
  }
  /**
   * Lifecycle method called when the host element is disconnected from the DOM.
   *
   * This method removes the event listener and cleans up resources.
   */
  hostDisconnected() {
    var _a;
    (_a = this.cleanup) == null ? void 0 : _a.call(this);
    this.cleanup = void 0;
    document.removeEventListener(
      "sp-update-overlays",
      this.resetOverlayPosition
    );
  }
};

// node_modules/@spectrum-web-components/overlay/src/InteractionController.dev.js
var InteractionTypes = ((InteractionTypes2) => {
  InteractionTypes2["click"] = "click";
  InteractionTypes2["hover"] = "hover";
  InteractionTypes2["longpress"] = "longpress";
  return InteractionTypes2;
})(InteractionTypes || {});
var lastInteractionType = /* @__PURE__ */ Symbol("lastInteractionType");
var InteractionController = class {
  constructor(target, { overlay, isPersistent, handleOverlayReady }) {
    this.target = target;
    this.isLazilyOpen = false;
    this.isPersistent = false;
    this.isPersistent = !!isPersistent;
    this.handleOverlayReady = handleOverlayReady;
    if (this.isPersistent) {
      this.init();
    }
    this.overlay = overlay;
  }
  get activelyOpening() {
    return false;
  }
  get open() {
    var _a, _b;
    return (_b = (_a = this.overlay) == null ? void 0 : _a.open) != null ? _b : this.isLazilyOpen;
  }
  /**
   * Set `open` against the associated Overlay lazily.
   */
  set open(open) {
    if (open === this.open) return;
    this.isLazilyOpen = open;
    if (this.overlay) {
      this.overlay.open = open;
      this.target[lastInteractionType] = this.type;
      return;
    }
    if (!open) {
      return;
    }
    customElements.whenDefined("sp-overlay").then(async () => {
      const { Overlay: Overlay2 } = await import("./Overlay.dev-D2P7YDTG.js");
      this.overlay = new Overlay2();
      this.overlay.open = true;
      this.target[lastInteractionType] = this.type;
    });
    import("./sp-overlay.dev-J2AT5RMJ.js");
  }
  get overlay() {
    return this._overlay;
  }
  set overlay(overlay) {
    var _a;
    if (!overlay) return;
    if (this.overlay === overlay) return;
    if (this.overlay) {
      this.overlay.removeController(this);
    }
    this._overlay = overlay;
    this.overlay.addController(this);
    this.initOverlay();
    this.prepareDescription(this.target);
    (_a = this.handleOverlayReady) == null ? void 0 : _a.call(this, this.overlay);
  }
  prepareDescription(_) {
  }
  releaseDescription() {
  }
  shouldCompleteOpen() {
  }
  /* c8 ignore next 3 */
  init() {
  }
  /* c8 ignore next 3 */
  initOverlay() {
  }
  abort() {
    var _a;
    this.releaseDescription();
    (_a = this.abortController) == null ? void 0 : _a.abort();
  }
  hostConnected() {
    this.init();
  }
  hostDisconnected() {
    if (!this.isPersistent) {
      this.abort();
    }
  }
};

// node_modules/@spectrum-web-components/overlay/src/LongpressController.dev.js
var LONGPRESS_DURATION = 300;
var LONGPRESS_INSTRUCTIONS = {
  touch: "Double tap and long press for additional options",
  keyboard: "Press Space or Alt+Down Arrow for additional options",
  mouse: "Click and hold for additional options"
};
var LongpressController = class extends InteractionController {
  constructor() {
    super(...arguments);
    this.type = InteractionTypes.longpress;
    this.longpressState = null;
    this.releaseDescription = noop;
    this.handlePointerup = () => {
      var _a;
      clearTimeout(this.timeout);
      if (!this.target) return;
      this.longpressState = ((_a = this.overlay) == null ? void 0 : _a.state) === "opening" ? "pressed" : null;
      document.removeEventListener("pointerup", this.handlePointerup);
      document.removeEventListener("pointercancel", this.handlePointerup);
    };
  }
  get activelyOpening() {
    return this.longpressState === "opening" || this.longpressState === "pressed";
  }
  handleLongpress() {
    this.open = true;
    this.longpressState = this.longpressState === "potential" ? "opening" : "pressed";
  }
  handlePointerdown(event) {
    if (!this.target) return;
    if (event.button !== 0) return;
    this.longpressState = "potential";
    document.addEventListener("pointerup", this.handlePointerup);
    document.addEventListener("pointercancel", this.handlePointerup);
    const triggerHandlesLongpress = "holdAffordance" in this.target;
    if (triggerHandlesLongpress) return;
    this.timeout = setTimeout(() => {
      if (!this.target) return;
      this.target.dispatchEvent(
        new CustomEvent("longpress", {
          bubbles: true,
          composed: true,
          detail: {
            source: "pointer"
          }
        })
      );
    }, LONGPRESS_DURATION);
  }
  handleKeydown(event) {
    const { code, altKey } = event;
    if (altKey && code === "ArrowDown") {
      event.stopPropagation();
      event.stopImmediatePropagation();
    }
  }
  handleKeyup(event) {
    const { code, altKey } = event;
    if (code === "Space" || altKey && code === "ArrowDown") {
      if (!this.target) {
        return;
      }
      event.stopPropagation();
      this.target.dispatchEvent(
        new CustomEvent("longpress", {
          bubbles: true,
          composed: true,
          detail: {
            source: "keyboard"
          }
        })
      );
      setTimeout(() => {
        this.longpressState = null;
      });
    }
  }
  prepareDescription(trigger) {
    if (
      // do not reapply until target is recycled
      this.releaseDescription !== noop || // require "longpress content" to apply relationship
      !this.overlay.elements.length
    ) {
      return;
    }
    const longpressDescription = document.createElement("div");
    longpressDescription.id = `longpress-describedby-descriptor-${randomID()}`;
    const messageType = isIOS() || isAndroid() ? "touch" : "keyboard";
    longpressDescription.textContent = LONGPRESS_INSTRUCTIONS[messageType];
    longpressDescription.slot = "longpress-describedby-descriptor";
    const triggerParent = trigger.getRootNode();
    const overlayParent = this.overlay.getRootNode();
    if (triggerParent === overlayParent) {
      this.overlay.append(longpressDescription);
    } else {
      longpressDescription.hidden = !("host" in triggerParent);
      trigger.insertAdjacentElement("afterend", longpressDescription);
    }
    const releaseDescription = conditionAttributeWithId(
      trigger,
      "aria-describedby",
      [longpressDescription.id]
    );
    this.releaseDescription = () => {
      releaseDescription();
      longpressDescription.remove();
      this.releaseDescription = noop;
    };
  }
  shouldCompleteOpen() {
    this.longpressState = this.longpressState === "pressed" ? null : this.longpressState;
  }
  init() {
    var _a;
    (_a = this.abortController) == null ? void 0 : _a.abort();
    this.abortController = new AbortController();
    const { signal } = this.abortController;
    this.target.addEventListener(
      "longpress",
      () => this.handleLongpress(),
      { signal }
    );
    this.target.addEventListener(
      "pointerdown",
      (event) => this.handlePointerdown(event),
      { signal }
    );
    this.prepareDescription(this.target);
    if (this.target.holdAffordance) {
      return;
    }
    this.target.addEventListener(
      "keydown",
      (event) => this.handleKeydown(event),
      { signal }
    );
    this.target.addEventListener(
      "keyup",
      (event) => this.handleKeyup(event),
      { signal }
    );
  }
};

// node_modules/@spectrum-web-components/overlay/src/ClickController.dev.js
var ClickController = class extends InteractionController {
  constructor() {
    super(...arguments);
    this.type = InteractionTypes.click;
    this.preventNextToggle = false;
  }
  handleClick() {
    if (!this.preventNextToggle) {
      this.open = !this.open;
    }
    this.preventNextToggle = false;
  }
  handlePointerdown() {
    this.preventNextToggle = this.open;
  }
  init() {
    var _a;
    (_a = this.abortController) == null ? void 0 : _a.abort();
    this.abortController = new AbortController();
    const { signal } = this.abortController;
    this.target.addEventListener("click", () => this.handleClick(), {
      signal
    });
    this.target.addEventListener(
      "pointerdown",
      () => this.handlePointerdown(),
      { signal }
    );
  }
};

// node_modules/@spectrum-web-components/overlay/src/HoverController.dev.js
var HoverController = class extends InteractionController {
  constructor() {
    super(...arguments);
    this.type = InteractionTypes.hover;
    this.elementIds = [];
    this.targetFocused = false;
    this.hovering = false;
    this.overlayFocused = false;
  }
  handleKeyup(event) {
    if (event.code === "Tab") {
      this.open = true;
    } else if (event.code === "Escape") {
      if (this.open) {
        event.preventDefault();
        event.stopPropagation();
        this.open = false;
        if (this.target) {
          this.target.focus();
        }
      }
    }
  }
  handleTargetFocusin() {
    if (!this.target.matches(":focus-visible")) {
      return;
    }
    if (isWebKit() && this.target[lastInteractionType] === InteractionTypes.click) {
      return;
    }
    this.open = true;
    this.targetFocused = true;
  }
  handleTargetFocusout() {
    this.targetFocused = false;
    if (this.hovering) return;
    this.doFocusleave();
  }
  clearCloseTimeout() {
    if (this.hoverTimeout) {
      clearTimeout(this.hoverTimeout);
      this.hoverTimeout = void 0;
    }
  }
  handleTargetPointerenter() {
    var _a;
    this.clearCloseTimeout();
    if ((_a = this.overlay) == null ? void 0 : _a.disabled) return;
    this.open = true;
    this.hovering = true;
  }
  handleTargetPointerleave() {
    this.doPointerleave();
  }
  // set a timeout once the pointer enters and the overlay is shown
  // give the user time to enter the overlay
  handleHostPointerenter() {
    this.clearCloseTimeout();
  }
  handleHostPointerleave() {
    this.doPointerleave();
  }
  handleOverlayFocusin() {
    this.overlayFocused = true;
    this.clearCloseTimeout();
  }
  handleOverlayFocusout() {
    this.overlayFocused = false;
    if (this.hovering) return;
    if (this.targetFocused && this.target.matches(":focus-visible")) return;
    this.doFocusleave();
  }
  prepareDescription() {
    if (!this.overlay.elements.length) return;
    const triggerRoot = this.target.getRootNode();
    const contentRoot = this.overlay.elements[0].getRootNode();
    const overlayRoot = this.overlay.getRootNode();
    if (triggerRoot === overlayRoot) {
      this.prepareOverlayRelativeDescription();
    } else if (triggerRoot === contentRoot) {
      this.prepareContentRelativeDescription();
    }
  }
  prepareOverlayRelativeDescription() {
    const releaseDescription = conditionAttributeWithId(
      this.target,
      "aria-describedby",
      [this.overlay.id]
    );
    this.releaseDescription = () => {
      releaseDescription();
      this.releaseDescription = noop;
    };
  }
  prepareContentRelativeDescription() {
    const elementIds = [];
    const appliedIds = this.overlay.elements.map((el) => {
      elementIds.push(el.id);
      if (!el.id) {
        el.id = `${this.overlay.tagName.toLowerCase()}-helper-${randomID()}`;
      }
      return el.id;
    });
    this.elementIds = elementIds;
    const releaseDescription = conditionAttributeWithId(
      this.target,
      "aria-describedby",
      appliedIds
    );
    this.releaseDescription = () => {
      releaseDescription();
      this.overlay.elements.map((el, index) => {
        el.id = this.elementIds[index];
      });
      this.releaseDescription = noop;
    };
  }
  scheduleClose() {
    this.hoverTimeout = setTimeout(() => {
      this.open = false;
    }, 300);
  }
  doPointerleave() {
    this.hovering = false;
    const triggerElement = this.target;
    if (this.targetFocused && triggerElement.matches(":focus-visible"))
      return;
    if (this.overlayFocused) return;
    this.scheduleClose();
  }
  doFocusleave() {
    this.clearCloseTimeout();
    if (!this.targetFocused && !this.overlayFocused && !this.hovering) {
      this.scheduleClose();
    }
  }
  init() {
    var _a;
    (_a = this.abortController) == null ? void 0 : _a.abort();
    this.abortController = new AbortController();
    const { signal } = this.abortController;
    this.target.addEventListener(
      "keyup",
      (event) => this.handleKeyup(event),
      { signal }
    );
    this.target.addEventListener(
      "focusin",
      () => this.handleTargetFocusin(),
      { signal }
    );
    this.target.addEventListener(
      "focusout",
      () => this.handleTargetFocusout(),
      { signal }
    );
    this.target.addEventListener(
      "pointerenter",
      () => this.handleTargetPointerenter(),
      { signal }
    );
    this.target.addEventListener(
      "pointerleave",
      () => this.handleTargetPointerleave(),
      { signal }
    );
    if (this.overlay) {
      this.initOverlay();
    }
  }
  initOverlay() {
    if (!this.abortController) {
      return;
    }
    const { signal } = this.abortController;
    this.overlay.addEventListener(
      "pointerenter",
      () => this.handleHostPointerenter(),
      { signal }
    );
    this.overlay.addEventListener(
      "pointerleave",
      () => this.handleHostPointerleave(),
      { signal }
    );
    this.overlay.addEventListener(
      "focusin",
      () => this.handleOverlayFocusin(),
      { signal }
    );
    this.overlay.addEventListener(
      "focusout",
      () => this.handleOverlayFocusout(),
      { signal }
    );
    this.overlay.addEventListener(
      "keyup",
      (event) => this.handleKeyup(event),
      { signal }
    );
  }
};

// node_modules/@spectrum-web-components/overlay/src/strategies.dev.js
var strategies = {
  click: ClickController,
  longpress: LongpressController,
  hover: HoverController
};

// node_modules/@spectrum-web-components/overlay/src/slottable-request-event.dev.js
var SlottableRequestEvent = class extends Event {
  constructor(name, data, key) {
    super("slottable-request", {
      bubbles: false,
      cancelable: true,
      composed: false
    });
    this.name = name;
    this.data = data;
    this.slotName = key !== void 0 ? `${name}.${key}` : name;
    if (true) {
      window.__swc.warn(
        void 0,
        `  WARNING  : \`slottable-request\` events are experimental and there is no guarantees behind usage of them in an application!! Their shape and presence within the library could be changed at anytime.

Learn more about the protocol these events are based on below:`,
        "https://github.com/webcomponents-cg/community-protocols/pull/45",
        {
          level: "high",
          type: "api"
        }
      );
    }
  }
};
var removeSlottableRequest = /* @__PURE__ */ Symbol("remove-slottable-request");

// node_modules/@spectrum-web-components/overlay/src/overlay.css.js
var o = css`
    :host{pointer-events:none;--swc-overlay-animation-distance:var(--spectrum-spacing-100);display:contents}:host(:has(>sp-tooltip)){--swc-overlay-animation-distance:var(--spectrum-tooltip-animation-distance)}.dialog{box-sizing:border-box;--sp-overlay-open:true;background:0 0;border:0;max-width:calc(100vw - 16px);height:auto;max-height:calc(100dvh - 16px);margin:0;padding:0;display:flex;position:fixed;inset:0 auto auto 0;overflow:visible;opacity:1!important}.dialog:not([is-visible]){display:none}.dialog:focus{outline:none}dialog:modal{--mod-popover-filter:var(--spectrum-popover-filter)}:host(:not([open])) .dialog{--sp-overlay-open:false}.dialog::backdrop{display:none}.dialog:before{content:"";position:absolute;inset:-999em;pointer-events:auto!important}.dialog:not(.not-immediately-closable):before{display:none}.dialog>div{width:100%}::slotted(*){pointer-events:auto;visibility:visible!important}::slotted(sp-popover){position:static}.dialog:not([actual-placement])[placement*=top]{padding-block:var(--swc-overlay-animation-distance);margin-top:var(--swc-overlay-animation-distance)}.dialog:not([actual-placement])[placement*=right]{padding-inline:var(--swc-overlay-animation-distance);margin-left:calc(-1*var(--swc-overlay-animation-distance))}.dialog:not([actual-placement])[placement*=bottom]{padding-block:var(--swc-overlay-animation-distance);margin-top:calc(-1*var(--swc-overlay-animation-distance))}.dialog:not([actual-placement])[placement*=left]{padding-inline:var(--swc-overlay-animation-distance);margin-left:var(--swc-overlay-animation-distance)}.dialog[actual-placement*=top]{padding-block:var(--swc-overlay-animation-distance);margin-top:var(--swc-overlay-animation-distance)}.dialog[actual-placement*=right]{padding-inline:var(--swc-overlay-animation-distance);margin-left:calc(-1*var(--swc-overlay-animation-distance))}.dialog[actual-placement*=bottom]{padding-block:var(--swc-overlay-animation-distance);margin-top:calc(-1*var(--swc-overlay-animation-distance))}.dialog[actual-placement*=left]{padding-inline:var(--swc-overlay-animation-distance);margin-left:var(--swc-overlay-animation-distance)}slot[name=longpress-describedby-descriptor]{display:none}@supports selector(:open){.dialog{opacity:0}.dialog:open{opacity:1;--mod-popover-filter:var(--spectrum-popover-filter)}}@supports selector(:popover-open){.dialog{opacity:0}.dialog:popover-open{opacity:1;--mod-popover-filter:var(--spectrum-popover-filter)}}@supports (overlay:auto){.dialog{transition:all var(--mod-overlay-animation-duration,var(--spectrum-animation-duration-100,.13s)),translate 0s,display var(--mod-overlay-animation-duration,var(--spectrum-animation-duration-100,.13s));transition-behavior:allow-discrete;display:none}.dialog:popover-open{display:flex}}@supports (not selector(:open)) and (not selector(:popover-open)){:host:not([open]) .dialog{pointer-events:none}.dialog[actual-placement]{z-index:calc(var(--swc-overlay-z-index-base,1000) + var(--swc-overlay-open-count))}}
`;
var overlay_css_default = o;

// node_modules/@spectrum-web-components/overlay/src/Overlay.dev.js
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};
var browserSupportsPopover = "showPopover" in document.createElement("div");
var ComputedOverlayBase = OverlayPopover(AbstractOverlay);
if (!browserSupportsPopover) {
  ComputedOverlayBase = OverlayNoPopover(AbstractOverlay);
}
var _Overlay = class _Overlay2 extends ComputedOverlayBase {
  constructor() {
    super(...arguments);
    this._delayed = false;
    this._disabled = false;
    this.offset = 0;
    this._open = false;
    this.lastRequestSlottableState = false;
    this.receivesFocus = "auto";
    this.allowOutsideClick = false;
    this._state = "closed";
    this.triggerElement = null;
    this.type = "auto";
    this.wasOpen = false;
    this._focusTrap = null;
    this.closeOnFocusOut = (event) => {
      if (!event.relatedTarget) {
        return;
      }
      const relationEvent = new Event("overlay-relation-query", {
        bubbles: true,
        composed: true
      });
      event.relatedTarget.addEventListener(
        relationEvent.type,
        (event2) => {
          const path = event2.composedPath();
          const isWithinOverlay = path.some((el) => el === this);
          if (!isWithinOverlay) {
            this.open = false;
          }
        }
      );
      event.relatedTarget.dispatchEvent(relationEvent);
    };
    this.closeOnCancelEvent = () => {
      this.open = false;
    };
  }
  get delayed() {
    var _a;
    return ((_a = this.elements.at(-1)) == null ? void 0 : _a.hasAttribute("delayed")) || this._delayed;
  }
  set delayed(delayed) {
    this._delayed = delayed;
  }
  get disabled() {
    return this._disabled;
  }
  set disabled(disabled) {
    var _a;
    this._disabled = disabled;
    if (disabled) {
      (_a = this.strategy) == null ? void 0 : _a.abort();
      this.wasOpen = this.open;
      this.open = false;
    } else {
      this.bindEvents();
      this.open = this.open || this.wasOpen;
      this.wasOpen = false;
    }
  }
  /**
   * Determines if the overlay has a non-virtual trigger element.
   *
   * @returns {boolean} `true` if the trigger element is not a virtual trigger, otherwise `false`.
   */
  get hasNonVirtualTrigger() {
    return !!this.triggerElement && !(this.triggerElement instanceof VirtualTrigger);
  }
  /**
   * Provides an instance of the `PlacementController` for managing the positioning
   * of the overlay relative to its trigger element.
   *
   * If the `PlacementController` instance does not already exist, it is created and
   * assigned to the `_placementController` property.
   *
   * @protected
   * @returns {PlacementController} The `PlacementController` instance.
   */
  get placementController() {
    if (!this._placementController) {
      this._placementController = new PlacementController(this);
    }
    return this._placementController;
  }
  get open() {
    return this._open;
  }
  set open(open) {
    var _a;
    if (open && this.disabled) return;
    if (open === this.open) return;
    if (((_a = this.strategy) == null ? void 0 : _a.activelyOpening) && !open) return;
    this._open = open;
    if (this.open) {
      _Overlay2.openCount += 1;
    }
    this.requestUpdate("open", !this.open);
    if (this.open) {
      this.requestSlottable();
    }
  }
  get state() {
    return this._state;
  }
  set state(state2) {
    var _a;
    if (state2 === this.state) return;
    const oldState = this.state;
    this._state = state2;
    if (this.state === "opened" || this.state === "closed") {
      (_a = this.strategy) == null ? void 0 : _a.shouldCompleteOpen();
    }
    this.requestUpdate("state", oldState);
  }
  /**
   * Provides an instance of the `ElementResolutionController` for managing the element
   * that the overlay should be associated with. If the instance does not already exist,
   * it is created and assigned to the `_elementResolver` property.
   *
   * @protected
   * @returns {ElementResolutionController} The `ElementResolutionController` instance.
   */
  get elementResolver() {
    if (!this._elementResolver) {
      this._elementResolver = new ElementResolutionController(this);
    }
    return this._elementResolver;
  }
  /**
   * Determines the value for the popover attribute based on the overlay type.
   *
   * @private
   * @returns {'auto' | 'manual' | undefined} The popover value or undefined if not applicable.
   */
  get popoverValue() {
    const hasPopoverAttribute = "popover" in this;
    if (!hasPopoverAttribute) {
      return void 0;
    }
    switch (this.type) {
      case "modal":
        return "auto";
      case "page":
        return "manual";
      case "hint":
        return "manual";
      default:
        return this.type;
    }
  }
  /**
   * Determines if the overlay requires positioning based on its type and state.
   *
   * @protected
   * @returns {boolean} True if the overlay requires positioning, otherwise false.
   */
  get requiresPositioning() {
    if (this.type === "page" || !this.open) return false;
    if (!this.triggerElement || !this.placement && this.type !== "hint")
      return false;
    return true;
  }
  /**
   * Manages the positioning of the overlay relative to its trigger element.
   *
   * This method calculates the necessary parameters for positioning the overlay,
   * such as offset, placement, and tip padding, and then delegates the actual
   * positioning to the `PlacementController`.
   *
   * @protected
   * @override
   */
  managePosition() {
    if (!this.requiresPositioning || !this.open) return;
    const offset3 = this.offset || 0;
    const trigger = this.triggerElement;
    const placement = this.placement || "right";
    const tipPadding = this.tipPadding;
    this.placementController.placeOverlay(this.dialogEl, {
      offset: offset3,
      placement,
      tipPadding,
      trigger,
      type: this.type
    });
  }
  /**
   * Manages the process of opening the popover.
   *
   * This method handles the necessary steps to open the popover, including managing delays,
   * ensuring the popover is in the DOM, making transitions, and applying focus.
   * @protected
   * @override
   * @returns {Promise<void>} A promise that resolves when the popover has been fully opened.
   */
  async managePopoverOpen() {
    super.managePopoverOpen();
    const targetOpenState = this.open;
    if (this.open !== targetOpenState) {
      return;
    }
    await this.manageDelay(targetOpenState);
    if (this.open !== targetOpenState) {
      return;
    }
    if (this.triggerInteraction === "longpress") {
      await nextFrame();
    }
    await this.ensureOnDOM(targetOpenState);
    if (this.open !== targetOpenState) {
      return;
    }
    const focusEl = await this.makeTransition(targetOpenState);
    if (this.open !== targetOpenState) {
      return;
    }
    if (targetOpenState) {
      const focusTrap = await import("./focus-trap.esm-67T25T3A.js");
      this._focusTrap = focusTrap.createFocusTrap(this.dialogEl, {
        initialFocus: focusEl || void 0,
        tabbableOptions: {
          getShadowRoot: true
        },
        fallbackFocus: () => {
          this.dialogEl.setAttribute("tabIndex", "-1");
          return this.dialogEl;
        },
        // disable escape key capture to close the overlay, the focus-trap library captures it otherwise
        escapeDeactivates: false,
        allowOutsideClick: this.allowOutsideClick
      });
      if (this.type === "modal" || this.type === "page") {
        this._focusTrap.activate();
      }
    }
    await this.applyFocus(targetOpenState, focusEl);
  }
  /**
   * Applies focus to the appropriate element after the popover has been opened.
   *
   * This method handles the focus management for the overlay, ensuring that the correct
   * element receives focus based on the overlay's type and state.
   *
   * @protected
   * @override
   * @param {boolean} targetOpenState - The target open state of the overlay.
   * @param {HTMLElement | null} focusEl - The element to focus after opening the popover.
   * @returns {Promise<void>} A promise that resolves when the focus has been applied.
   */
  async applyFocus(targetOpenState, focusEl) {
    if (this.receivesFocus === "false" || this.type === "hint") {
      return;
    }
    await nextFrame();
    await nextFrame();
    if (targetOpenState === this.open && !this.open) {
      if (this.hasNonVirtualTrigger && this.contains(this.getRootNode().activeElement)) {
        this.triggerElement.focus();
      }
      return;
    }
    focusEl == null ? void 0 : focusEl.focus();
  }
  /**
   * Returns focus to the trigger element if the overlay is closed.
   *
   * This method ensures that focus is returned to the trigger element when the overlay is closed,
   * unless the overlay is of type "hint" or the focus is already outside the overlay.
   *
   * @protected
   * @override
   */
  returnFocus() {
    var _a;
    if (this.open || this.type === "hint") return;
    const getAncestors = () => {
      var _a2, _b;
      const ancestors = [];
      let currentNode = document.activeElement;
      while ((_a2 = currentNode == null ? void 0 : currentNode.shadowRoot) == null ? void 0 : _a2.activeElement) {
        currentNode = currentNode.shadowRoot.activeElement;
      }
      while (currentNode) {
        const ancestor = currentNode.assignedSlot || currentNode.parentElement || ((_b = currentNode.getRootNode()) == null ? void 0 : _b.host);
        if (ancestor) {
          ancestors.push(ancestor);
        }
        currentNode = ancestor;
      }
      return ancestors;
    };
    if (this.receivesFocus !== "false" && !!((_a = this.triggerElement) == null ? void 0 : _a.focus) && (this.contains(this.getRootNode().activeElement) || getAncestors().includes(this) || // eslint-disable-next-line @spectrum-web-components/document-active-element
    document.activeElement === document.body)) {
      this.triggerElement.focus();
    }
  }
  /**
   * Manages the process of opening or closing the overlay.
   *
   * This method handles the necessary steps to open or close the overlay, including updating the state,
   * managing the overlay stack, and handling focus events.
   *
   * @protected
   * @param {boolean} oldOpen - The previous open state of the overlay.
   * @returns {Promise<void>} A promise that resolves when the overlay has been fully managed.
   */
  async manageOpen(oldOpen) {
    var _a;
    if (!this.isConnected && this.open) return;
    if (!this.hasUpdated) {
      await this.updateComplete;
    }
    if (this.open) {
      overlayStack.add(this);
      if (this.willPreventClose) {
        document.addEventListener(
          "pointerup",
          () => {
            this.dialogEl.classList.toggle(
              "not-immediately-closable",
              false
            );
            this.willPreventClose = false;
          },
          { once: true }
        );
        this.dialogEl.classList.toggle(
          "not-immediately-closable",
          true
        );
      }
    } else {
      if (oldOpen) {
        (_a = this._focusTrap) == null ? void 0 : _a.deactivate();
        this._focusTrap = null;
        this.dispose();
      }
      overlayStack.remove(this);
    }
    if (this.open && this.state !== "opened") {
      this.state = "opening";
    } else if (!this.open && this.state !== "closed") {
      this.state = "closing";
    }
    this.managePopoverOpen();
    const listenerRoot = this.getRootNode();
    if (this.type === "auto") {
      if (this.open) {
        listenerRoot.addEventListener(
          "focusout",
          this.closeOnFocusOut,
          { capture: true }
        );
      } else {
        listenerRoot.removeEventListener(
          "focusout",
          this.closeOnFocusOut,
          { capture: true }
        );
      }
    }
    if (this.type === "modal" || this.type === "page") {
      if (this.open) {
        listenerRoot.addEventListener(
          "cancel",
          this.closeOnCancelEvent,
          {
            capture: true
          }
        );
      } else {
        listenerRoot.removeEventListener(
          "cancel",
          this.closeOnCancelEvent,
          {
            capture: true
          }
        );
      }
    }
  }
  /**
   * Binds event handling strategies to the overlay based on the specified trigger interaction.
   *
   * This method sets up the appropriate event handling strategy for the overlay, ensuring that
   * it responds correctly to user interactions such as clicks, hovers, or long presses.
   *
   * @protected
   */
  bindEvents() {
    var _a;
    (_a = this.strategy) == null ? void 0 : _a.abort();
    this.strategy = void 0;
    if (!this.hasNonVirtualTrigger) return;
    if (!this.triggerInteraction) return;
    this.strategy = new strategies[this.triggerInteraction](
      this.triggerElement,
      {
        overlay: this
      }
    );
  }
  /**
   * Handles the `beforetoggle` event to manage the overlay's state.
   *
   * This method checks the new state of the event and calls `handleBrowserClose`
   * if the new state is not 'open'.
   *
   * @protected
   * @param {Event & { newState: string }} event - The `beforetoggle` event with the new state.
   */
  handleBeforetoggle(event) {
    if (event.newState !== "open") {
      this.handleBrowserClose(event);
    }
  }
  /**
   * Handles the browser's close event to manage the overlay's state.
   *
   * This method stops the propagation of the event and closes the overlay if it is not
   * actively opening. If the overlay is actively opening, it calls `manuallyKeepOpen`.
   *
   * @protected
   * @param {Event} event - The browser's close event.
   */
  handleBrowserClose(event) {
    var _a;
    event.stopPropagation();
    if (!((_a = this.strategy) == null ? void 0 : _a.activelyOpening)) {
      this.open = false;
      return;
    }
    this.manuallyKeepOpen();
  }
  /**
   * Manually keeps the overlay open.
   *
   * This method sets the overlay to open, allows placement updates, and manages the open state.
   *
   * @public
   * @override
   */
  manuallyKeepOpen() {
    this.open = true;
    this.placementController.allowPlacementUpdate = true;
    this.manageOpen(false);
  }
  /**
   * Handles the `slotchange` event to manage the overlay's state.
   *
   * This method checks if there are any elements in the slot. If there are no elements,
   * it releases the description from the strategy. If there are elements and the trigger
   * is non-virtual, it prepares the description for the trigger element.
   *
   * @protected
   */
  handleSlotchange() {
    var _a, _b;
    if (!this.elements.length) {
      (_a = this.strategy) == null ? void 0 : _a.releaseDescription();
    } else if (this.hasNonVirtualTrigger) {
      (_b = this.strategy) == null ? void 0 : _b.prepareDescription(
        this.triggerElement
      );
    }
  }
  /**
   * Determines whether the overlay should prevent closing.
   *
   * This method checks the `willPreventClose` flag and resets it to `false`.
   * It returns the value of the `willPreventClose` flag.
   *
   * @public
   * @returns {boolean} `true` if the overlay should prevent closing, otherwise `false`.
   */
  shouldPreventClose() {
    const shouldPreventClose = this.willPreventClose;
    this.willPreventClose = false;
    return shouldPreventClose;
  }
  /**
   * Requests slottable content for the overlay.
   *
   * This method dispatches a `SlottableRequestEvent` to request or remove slottable content
   * based on the current open state of the overlay. It ensures that the same state is not
   * dispatched twice in a row.
   *
   * @protected
   * @override
   */
  requestSlottable() {
    if (this.lastRequestSlottableState === this.open) {
      return;
    }
    if (!this.open) {
      document.body.offsetHeight;
    }
    this.dispatchEvent(
      new SlottableRequestEvent(
        "overlay-content",
        this.open ? {} : removeSlottableRequest
      )
    );
    this.lastRequestSlottableState = this.open;
  }
  /**
   * Lifecycle method called before the component updates.
   *
   * This method handles various tasks before the component updates, such as setting an ID,
   * managing the open state, resolving the trigger element, and binding events.
   *
   * @override
   * @param {PropertyValues} changes - The properties that have changed.
   */
  willUpdate(changes) {
    var _a;
    if (!this.hasAttribute("id")) {
      this.setAttribute(
        "id",
        `${this.tagName.toLowerCase()}-${randomID()}`
      );
    }
    if (changes.has("allowOutsideClick") && this.allowOutsideClick) {
      if (true) {
        window.__swc.warn(
          this,
          `The "allow-outside-click" attribute on <${this.localName}> has been deprecated and will be removed in a future release. We do not recommend using this attribute for accessibility reasons. It allows clicks outside the overlay to close it, which can cause unexpected behavior and accessibility issues.`,
          "https://opensource.adobe.com/spectrum-web-components/components/overlay/",
          { level: "deprecation" }
        );
      } else {
        console.warn(
          `[${this.localName}] The "allow-outside-click" attribute has been deprecated and will be removed in a future release. We do not recommend using this attribute for accessibility reasons. It allows clicks outside the overlay to close it, which can cause unexpected behavior and accessibility issues.`
        );
      }
    }
    if (changes.has("open") && (this.hasUpdated || this.open)) {
      this.manageOpen(changes.get("open"));
    }
    if (changes.has("trigger")) {
      const [id, interaction] = ((_a = this.trigger) == null ? void 0 : _a.split("@")) || [];
      this.elementResolver.selector = id ? `#${id}` : "";
      this.triggerInteraction = interaction;
    }
    let oldTrigger = false;
    if (changes.has(elementResolverUpdatedSymbol)) {
      oldTrigger = this.triggerElement;
      this.triggerElement = this.elementResolver.element;
    }
    if (changes.has("triggerElement")) {
      oldTrigger = changes.get("triggerElement");
    }
    if (oldTrigger !== false) {
      this.bindEvents();
    }
  }
  /**
   * Lifecycle method called after the component updates.
   *
   * This method handles various tasks after the component updates, such as updating the placement
   * attribute, resetting the overlay position, and clearing the overlay position based on the state.
   *
   * @override
   * @param {PropertyValues} changes - The properties that have changed.
   */
  updated(changes) {
    super.updated(changes);
    if (changes.has("placement")) {
      if (this.placement) {
        this.dialogEl.setAttribute("actual-placement", this.placement);
      } else {
        this.dialogEl.removeAttribute("actual-placement");
      }
      if (this.open && typeof changes.get("placement") !== "undefined") {
        this.placementController.resetOverlayPosition();
      }
    }
    if (changes.has("state") && this.state === "closed" && typeof changes.get("state") !== "undefined") {
      this.placementController.clearOverlayPosition();
    }
  }
  /**
   * Renders the content of the overlay.
   *
   * This method returns a template result containing a slot element. The slot element
   * listens for the `slotchange` event to manage the overlay's state.
   *
   * @protected
   * @returns {TemplateResult} The template result containing the slot element.
   */
  renderContent() {
    return html`
            <slot @slotchange=${this.handleSlotchange}></slot>
        `;
  }
  /**
   * Generates a style map for the dialog element.
   *
   * This method returns an object containing CSS custom properties for the dialog element.
   * The `--swc-overlay-open-count` custom property is set to the current open count of overlays.
   *
   * @private
   * @returns {StyleInfo} The style map for the dialog element.
   */
  get dialogStyleMap() {
    return {
      "--swc-overlay-open-count": _Overlay2.openCount.toString()
    };
  }
  /**
   * Renders the popover element for the overlay.
   *
   * This method returns a template result containing a div element styled as a popover.
   * The popover element includes various attributes and event listeners to manage the overlay's state and behavior.
   *
   * @protected
   * @returns {TemplateResult} The template result containing the popover element.
   */
  renderPopover() {
    return html`
            <div
                class="dialog"
                part="dialog"
                role=${ifDefined(
      this.type === "modal" || this.type === "page" ? "dialog" : void 0
    )}
                aria-modal=${ifDefined(
      this.type === "modal" || this.type === "page" ? "true" : void 0
    )}
                placement=${ifDefined(
      this.requiresPositioning ? this.placement || "right" : void 0
    )}
                popover=${ifDefined(this.popoverValue)}
                style=${styleMap(this.dialogStyleMap)}
                @beforetoggle=${this.handleBeforetoggle}
                @close=${this.handleBrowserClose}
                ?is-visible=${this.state !== "closed"}
            >
                ${this.renderContent()}
            </div>
        `;
  }
  /**
   * Renders the overlay component.
   *
   * This method returns a template result containing either a dialog or popover element
   * based on the overlay type. It also includes a slot for longpress descriptors.
   *
   * @override
   * @returns {TemplateResult} The template result containing the overlay content.
   */
  render() {
    return html`
            ${this.renderPopover()}
            <slot name="longpress-describedby-descriptor"></slot>
        `;
  }
  /**
   * Lifecycle method called when the component is added to the DOM.
   *
   * This method sets up event listeners and binds events if the component has already updated.
   *
   * @override
   */
  connectedCallback() {
    super.connectedCallback();
    this.addEventListener("close", () => {
      this.open = false;
    });
    if (this.hasUpdated) {
      this.bindEvents();
    }
  }
  /**
   * Lifecycle method called when the component is removed from the DOM.
   *
   * This method releases the description from the strategy and updates the 'open' property.
   *
   * @override
   */
  disconnectedCallback() {
    var _a;
    (_a = this.strategy) == null ? void 0 : _a.releaseDescription();
    this.open = false;
    super.disconnectedCallback();
  }
};
_Overlay.styles = [overlay_css_default];
_Overlay.openCount = 1;
__decorateClass([
  property({ type: Boolean })
], _Overlay.prototype, "delayed", 1);
__decorateClass([
  query(".dialog")
], _Overlay.prototype, "dialogEl", 2);
__decorateClass([
  property({ type: Boolean })
], _Overlay.prototype, "disabled", 1);
__decorateClass([
  queryAssignedElements({
    flatten: true,
    selector: ':not([slot="longpress-describedby-descriptor"], slot)'
  })
], _Overlay.prototype, "elements", 2);
__decorateClass([
  property({ type: Number })
], _Overlay.prototype, "offset", 2);
__decorateClass([
  property({ type: Boolean, reflect: true })
], _Overlay.prototype, "open", 1);
__decorateClass([
  property()
], _Overlay.prototype, "placement", 2);
__decorateClass([
  property({ attribute: "receives-focus" })
], _Overlay.prototype, "receivesFocus", 2);
__decorateClass([
  property({ type: Boolean, attribute: "allow-outside-click" })
], _Overlay.prototype, "allowOutsideClick", 2);
__decorateClass([
  query("slot")
], _Overlay.prototype, "slotEl", 2);
__decorateClass([
  state()
], _Overlay.prototype, "state", 1);
__decorateClass([
  property({ type: Number, attribute: "tip-padding" })
], _Overlay.prototype, "tipPadding", 2);
__decorateClass([
  property()
], _Overlay.prototype, "trigger", 2);
__decorateClass([
  property({ attribute: false })
], _Overlay.prototype, "triggerElement", 2);
__decorateClass([
  property({ attribute: false })
], _Overlay.prototype, "triggerInteraction", 2);
__decorateClass([
  property()
], _Overlay.prototype, "type", 2);
var Overlay = _Overlay;

export {
  elementResolverUpdatedSymbol,
  ElementResolutionController,
  LONGPRESS_INSTRUCTIONS,
  SlottableRequestEvent,
  removeSlottableRequest,
  Overlay
};
//# sourceMappingURL=chunk-Q23V2PYX.js.map
