{
  "version": 3,
  "sources": ["HoverController.ts"],
  "sourcesContent": ["/**\n * Copyright 2025 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport { conditionAttributeWithId } from '@spectrum-web-components/base/src/condition-attribute-with-id.js';\nimport { isWebKit } from '@spectrum-web-components/shared';\nimport { randomID } from '@spectrum-web-components/shared/src/random-id.js';\nimport { noop } from './AbstractOverlay.dev.js'\nimport {\n    InteractionController,\n    InteractionTypes,\n    lastInteractionType,\n} from './InteractionController.dev.js'\n\nexport class HoverController extends InteractionController {\n    override type = InteractionTypes.hover;\n\n    private elementIds: string[] = [];\n\n    private targetFocused = false;\n\n    private hoverTimeout?: ReturnType<typeof setTimeout>;\n\n    private hovering = false;\n\n    private overlayFocused = false;\n\n    handleKeyup(event: KeyboardEvent): void {\n        if (event.code === 'Tab') {\n            this.open = true;\n        } else if (event.code === 'Escape') {\n            if (this.open) {\n                event.preventDefault();\n                event.stopPropagation();\n                this.open = false;\n                // Return focus to trigger element\n                if (this.target) {\n                    this.target.focus();\n                }\n            }\n        }\n    }\n\n    handleTargetFocusin(): void {\n        if (!this.target.matches(':focus-visible')) {\n            return;\n        }\n\n        if (\n            isWebKit() &&\n            this.target[lastInteractionType] === InteractionTypes.click\n        ) {\n            return;\n        }\n\n        this.open = true;\n        this.targetFocused = true;\n    }\n\n    handleTargetFocusout(): void {\n        this.targetFocused = false;\n        // Don't close immediately if pointer is over the content\n        if (this.hovering) return;\n        // Use delay to allow focus to move into overlay content\n        this.doFocusleave();\n    }\n\n    private clearCloseTimeout(): void {\n        if (this.hoverTimeout) {\n            clearTimeout(this.hoverTimeout);\n            this.hoverTimeout = undefined;\n        }\n    }\n\n    handleTargetPointerenter(): void {\n        this.clearCloseTimeout();\n        if (this.overlay?.disabled) return;\n        this.open = true;\n        this.hovering = true;\n    }\n\n    handleTargetPointerleave(): void {\n        this.doPointerleave();\n    }\n\n    // set a timeout once the pointer enters and the overlay is shown\n    // give the user time to enter the overlay\n    handleHostPointerenter(): void {\n        this.clearCloseTimeout();\n    }\n\n    handleHostPointerleave(): void {\n        this.doPointerleave();\n    }\n\n    handleOverlayFocusin(): void {\n        this.overlayFocused = true;\n        // Clear any pending close timeout when focus enters overlay\n        this.clearCloseTimeout();\n    }\n\n    handleOverlayFocusout(): void {\n        this.overlayFocused = false;\n        // Don't close immediately if pointer is over the content or trigger has focus\n        if (this.hovering) return;\n        if (this.targetFocused && this.target.matches(':focus-visible')) return;\n        // Use delay before closing\n        this.doFocusleave();\n    }\n\n    override prepareDescription(): void {\n        // require \"content\" to apply relationship\n        if (!this.overlay.elements.length) return;\n\n        const triggerRoot = this.target.getRootNode();\n        const contentRoot = this.overlay.elements[0].getRootNode();\n        const overlayRoot = this.overlay.getRootNode();\n        if (triggerRoot === overlayRoot) {\n            this.prepareOverlayRelativeDescription();\n        } else if (triggerRoot === contentRoot) {\n            this.prepareContentRelativeDescription();\n        }\n    }\n\n    private prepareOverlayRelativeDescription(): void {\n        const releaseDescription = conditionAttributeWithId(\n            this.target,\n            'aria-describedby',\n            [this.overlay.id]\n        );\n        this.releaseDescription = () => {\n            releaseDescription();\n            this.releaseDescription = noop;\n        };\n    }\n\n    private prepareContentRelativeDescription(): void {\n        const elementIds: string[] = [];\n        const appliedIds = this.overlay.elements.map((el) => {\n            elementIds.push(el.id);\n            if (!el.id) {\n                el.id = `${this.overlay.tagName.toLowerCase()}-helper-${randomID()}`;\n            }\n            return el.id;\n        });\n        this.elementIds = elementIds;\n        const releaseDescription = conditionAttributeWithId(\n            this.target,\n            'aria-describedby',\n            appliedIds\n        );\n        this.releaseDescription = () => {\n            releaseDescription();\n            this.overlay.elements.map((el, index) => {\n                el.id = this.elementIds[index];\n            });\n            this.releaseDescription = noop;\n        };\n    }\n\n    private scheduleClose(): void {\n        this.hoverTimeout = setTimeout(() => {\n            this.open = false;\n        }, 300);\n    }\n\n    private doPointerleave(): void {\n        this.hovering = false;\n        const triggerElement = this.target as HTMLElement;\n        if (this.targetFocused && triggerElement.matches(':focus-visible'))\n            return;\n        // Don't close if focus is within overlay content\n        if (this.overlayFocused) return;\n\n        this.scheduleClose();\n    }\n\n    private doFocusleave(): void {\n        // Clear any existing timeout\n        this.clearCloseTimeout();\n\n        // Use same delay as pointer interactions for consistency\n        if (!this.targetFocused && !this.overlayFocused && !this.hovering) {\n            this.scheduleClose();\n        }\n    }\n\n    override init(): void {\n        // Clean up listeners if they've already been bound\n        this.abortController?.abort();\n        this.abortController = new AbortController();\n        const { signal } = this.abortController;\n        this.target.addEventListener(\n            'keyup',\n            (event) => this.handleKeyup(event),\n            { signal }\n        );\n        this.target.addEventListener(\n            'focusin',\n            () => this.handleTargetFocusin(),\n            { signal }\n        );\n        this.target.addEventListener(\n            'focusout',\n            () => this.handleTargetFocusout(),\n            { signal }\n        );\n        this.target.addEventListener(\n            'pointerenter',\n            () => this.handleTargetPointerenter(),\n            { signal }\n        );\n        this.target.addEventListener(\n            'pointerleave',\n            () => this.handleTargetPointerleave(),\n            { signal }\n        );\n        if (this.overlay) {\n            this.initOverlay();\n        }\n    }\n\n    override initOverlay(): void {\n        if (!this.abortController) {\n            return;\n        }\n        const { signal } = this.abortController;\n        this.overlay.addEventListener(\n            'pointerenter',\n            () => this.handleHostPointerenter(),\n            { signal }\n        );\n        this.overlay.addEventListener(\n            'pointerleave',\n            () => this.handleHostPointerleave(),\n            { signal }\n        );\n        this.overlay.addEventListener(\n            'focusin',\n            () => this.handleOverlayFocusin(),\n            { signal }\n        );\n        this.overlay.addEventListener(\n            'focusout',\n            () => this.handleOverlayFocusout(),\n            { signal }\n        );\n        this.overlay.addEventListener(\n            'keyup',\n            (event) => this.handleKeyup(event),\n            { signal }\n        );\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
