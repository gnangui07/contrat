{
  "version": 3,
  "sources": ["Tooltip.ts"],
  "sourcesContent": ["/**\n * Copyright 2025 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {\n    CSSResultArray,\n    html,\n    SpectrumElement,\n    TemplateResult,\n} from '@spectrum-web-components/base';\nimport {\n    property,\n    query,\n} from '@spectrum-web-components/base/src/decorators.js';\nimport { ifDefined } from '@spectrum-web-components/base/src/directives.js';\nimport type {\n    Overlay,\n    OverlayOpenCloseDetail,\n    Placement,\n} from '@spectrum-web-components/overlay';\n\nimport { DependencyManagerController } from '@spectrum-web-components/reactive-controllers/src/DependencyManger.js';\nimport { focusableSelector } from '@spectrum-web-components/shared/src/focusable-selectors.js';\nimport tooltipStyles from './tooltip.css.js';\n\nclass TooltipOpenable extends HTMLElement {\n    constructor() {\n        super();\n        this.addEventListener('sp-opened', this.redispatchEvent);\n        this.addEventListener('sp-closed', this.redispatchEvent);\n    }\n    redispatchEvent(event: Event): void {\n        event.stopPropagation();\n        this.tooltip.dispatchEvent(\n            new CustomEvent<OverlayOpenCloseDetail>(event.type, {\n                bubbles: event.bubbles,\n                composed: event.composed,\n                detail: (event as CustomEvent<OverlayOpenCloseDetail>).detail,\n            })\n        );\n    }\n    get tooltip(): Tooltip {\n        return (this.getRootNode() as ShadowRoot).host as Tooltip;\n    }\n    static get observedAttributes(): string[] {\n        return ['open', 'placement'];\n    }\n    attributeChangedCallback(\n        name: 'open' | 'placement',\n        _oldValue: string,\n        newValue: 'string'\n    ): void {\n        switch (name) {\n            // API generally sets `open` as a property\n            /* c8 ignore next 3 */\n            case 'open':\n                this.open = newValue !== null;\n                break;\n            case 'placement':\n                this.placement = newValue as Placement;\n                break;\n        }\n    }\n    set open(open: boolean) {\n        this._open = open;\n        const { tooltip } = this;\n        /* c8 ignore next 3 */\n        if (!tooltip) {\n            return;\n        }\n        tooltip.open = open;\n    }\n    /* c8 ignore next 3 */\n    get open(): boolean {\n        return this._open;\n    }\n    private _open = false;\n    /**\n     * @type {\"top\" | \"top-start\" | \"top-end\" | \"right\" | \"right-start\" | \"right-end\" | \"bottom\" | \"bottom-start\" | \"bottom-end\" | \"left\" | \"left-start\" | \"left-end\"}\n     * @attr\n     */\n    set placement(placement: Placement) {\n        this._placement = placement;\n        const { tooltip } = this;\n        if (!tooltip) {\n            return;\n        }\n        tooltip.placement = placement;\n    }\n    /* c8 ignore next 3 */\n    get placement(): Placement {\n        return this._placement;\n    }\n    private _placement: Placement = 'top';\n    get tipElement(): HTMLElement {\n        return this.tooltip.tipElement;\n    }\n}\n\nif (!customElements.get('sp-tooltip-openable')) {\n    customElements.define('sp-tooltip-openable', TooltipOpenable);\n}\n\n/**\n * @element sp-tooltip\n *\n * @slot icon - the icon element appearing at the start of the label\n * @slot - the text label of the Tooltip\n */\nexport class Tooltip extends SpectrumElement {\n    public static override get styles(): CSSResultArray {\n        return [tooltipStyles];\n    }\n\n    /**\n     * A Tooltip that is `delayed` will its Overlay wait until a warm-up period of\n     * 1000ms has completed before opening. Once the warmup period has completed, all\n     * subsequent Overlays will open immediately. When no Overlays are opened, a\n     * cooldown period of 1000ms will begin. Once the cooldown has completed, the next\n     * Overlay to be opened will be subject to the warm-up period if provided that option.\n     */\n    @property({ type: Boolean })\n    delayed = false;\n\n    private dependencyManager = new DependencyManagerController(this);\n\n    /**\n     * Whether to prevent a self-managed Tooltip from responding to user input.\n     */\n    @property({ type: Boolean })\n    disabled = false;\n\n    /**\n     * Automatically bind to the parent element of the assigned `slot` or the parent element of the `sp-tooltip`.\n     * Without this, you must provide your own `overlay-trigger`.\n     */\n    @property({ type: Boolean, attribute: 'self-managed' })\n    public selfManaged = false;\n\n    @property({ type: Number })\n    public offset = 0;\n\n    @property({ type: Boolean, reflect: true })\n    public open = false;\n\n    @query('sp-overlay')\n    public overlayElement?: Overlay;\n\n    /**\n     * @type {\"top\" | \"top-start\" | \"top-end\" | \"right\" | \"right-start\" | \"right-end\" | \"bottom\" | \"bottom-start\" | \"bottom-end\" | \"left\" | \"left-start\" | \"left-end\"}\n     * @attr\n     */\n    @property({ reflect: true })\n    public placement?: Placement;\n\n    @query('#tip')\n    public tipElement!: HTMLSpanElement;\n\n    @property({ type: Number })\n    public tipPadding?: number;\n\n    /* Ensure that a '' value for `variant` removes the attribute instead of a blank value */\n    private _variant = '';\n\n    @property({ type: String })\n    public get variant(): string {\n        return this._variant;\n    }\n    public set variant(variant: string) {\n        if (variant === this.variant) {\n            return;\n        }\n        if (['info', 'positive', 'negative'].includes(variant)) {\n            this.setAttribute('variant', variant);\n            this._variant = variant;\n            return;\n        }\n        this.removeAttribute('variant');\n        this._variant = '';\n    }\n\n    private handleOpenOverlay = (): void => {\n        this.open = true;\n    };\n\n    protected handleCloseOverlay = (): void => {\n        this.open = false;\n    };\n\n    protected forwardTransitionEvent(event: TransitionEvent): void {\n        this.dispatchEvent(\n            new TransitionEvent(event.type, {\n                bubbles: true,\n                composed: true,\n                propertyName: event.propertyName,\n            })\n        );\n    }\n\n    /**\n     * Finds the trigger element for a self-managed tooltip by traversing up the composed DOM tree.\n     *\n     * Self-managed tooltips automatically bind to their first focusable ancestor element.\n     * This method walks up through shadow DOM boundaries to find a suitable trigger element.\n     *\n     * A trigger element must match the focusableSelector, which includes:\n     * - Interactive elements like buttons, inputs, links, etc.\n     * - Elements with tabindex (except -1)\n     * - Elements with focusable=\"true\"\n     *\n     * Common scenarios where no trigger element is found:\n     * 1. Tooltip is placed directly in document body without a focusable parent\n     * 2. Tooltip is nested in non-interactive elements (divs, spans) without focusable ancestors\n     * 3. All ancestor elements have tabindex=\"-1\" or are otherwise non-focusable\n     *\n     * Expected usage: <sp-action-button><sp-tooltip self-managed>...</sp-tooltip></sp-action-button>\n     *\n     * @returns The first focusable ancestor element, or null if none found\n     */\n    private get triggerElement(): HTMLElement | null {\n        // Start from the assigned slot (if tooltip is slotted) or the tooltip itself\n        let start: HTMLElement = this.assignedSlot || this;\n        let root = start.getRootNode();\n\n        // Check if we've reached the document root without finding a parent\n        // This happens when the tooltip is at the top level without a container\n        if (root === document) {\n            if (window.__swc.DEBUG) {\n                window.__swc.warn(\n                    this,\n                    `[INITIAL_TRAVERSAL] Self-managed <${this.localName}> is at document root without a parent element. Self-managed tooltips must be nested inside focusable elements like <sp-action-button>, <sp-button>, or elements with tabindex.`,\n                    'https://opensource.adobe.com/spectrum-web-components/components/tooltip#self-managed-overlays',\n                    {\n                        level: 'high',\n                    }\n                );\n            }\n            return null;\n        }\n\n        // Get the initial candidate trigger element:\n        // 1. Direct parent element in the same document/shadow root\n        // 2. Shadow host if we're in a shadow root\n        // 3. The root itself as fallback\n        let triggerElement = (start.parentElement ||\n            (root as ShadowRoot).host ||\n            root) as HTMLElement;\n\n        // Walk up the composed tree until we find a focusable element\n        // The focusableSelector matches interactive elements that can receive focus\n        while (!triggerElement?.matches?.(focusableSelector)) {\n            // Move to the next level up in the composed tree\n            // This handles both regular DOM and shadow DOM traversal\n            start =\n                triggerElement.assignedSlot || (triggerElement as HTMLElement);\n            root = start.getRootNode();\n\n            /* c8 ignore next 13 */\n            // Check if we've reached the document root during traversal\n            // This happens when no focusable ancestor is found\n            if (root === document) {\n                if (window.__swc.DEBUG) {\n                    window.__swc.warn(\n                        this,\n                        `[TRAVERSAL_EXHAUSTED] Self-managed <${this.localName}> could not find a focusable trigger element. All ancestor elements are non-focusable. Ensure the tooltip is nested inside an interactive element like <sp-action-button>, <sp-button>, or add tabindex=\"0\" to a parent element.`,\n                        'https://opensource.adobe.com/spectrum-web-components/components/tooltip#self-managed-overlays',\n                        {\n                            level: 'high',\n                        }\n                    );\n                }\n                return null;\n            }\n\n            // Continue traversing up to find the next candidate\n            triggerElement = (start.parentElement ||\n                (root as ShadowRoot).host ||\n                /* c8 ignore next 1 */\n                root) as HTMLElement;\n        }\n\n        return triggerElement;\n    }\n\n    override render(): TemplateResult {\n        const tooltip = html`\n            <sp-tooltip-openable\n                id=\"tooltip\"\n                placement=${ifDefined(this.placement)}\n                @transitionrun=${this.forwardTransitionEvent}\n                @transitionend=${this.forwardTransitionEvent}\n                @transitioncancel=${this.forwardTransitionEvent}\n            >\n                <slot name=\"icon\"></slot>\n                <span id=\"label\"><slot></slot></span>\n                <span id=\"tip\" aria-hidden=\"true\"></span>\n            </sp-tooltip-openable>\n        `;\n        if (this.selfManaged) {\n            this.dependencyManager.add('sp-overlay');\n            import('@spectrum-web-components/overlay/sp-overlay.js');\n            return html`\n                <sp-overlay\n                    ?open=${this.open &&\n                    !this.disabled &&\n                    this.dependencyManager.loaded}\n                    ?delayed=${this.delayed}\n                    ?disabled=${this.disabled}\n                    offset=${this.offset}\n                    .placement=${this.placement}\n                    type=\"hint\"\n                    .tipPadding=${this.tipPadding}\n                    .triggerInteraction=${'hover'}\n                    @sp-opened=${this.handleOpenOverlay}\n                    @sp-closed=${this.handleCloseOverlay}\n                >\n                    ${tooltip}\n                </sp-overlay>\n            `;\n        } else {\n            return tooltip;\n        }\n    }\n\n    public override connectedCallback(): void {\n        super.connectedCallback();\n\n        this.updateComplete.then(() => {\n            if (!this.selfManaged) {\n                return;\n            }\n            const overlayElement = this.overlayElement;\n            if (overlayElement) {\n                const triggerElement = this.triggerElement;\n                overlayElement.triggerElement = triggerElement;\n            }\n        });\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
